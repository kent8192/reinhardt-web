# Part 1: Project Setup

In this tutorial, we'll create a new Reinhardt project and write our first view.

## Verifying Your Installation

Before we begin, let's verify that Rust and Cargo are installed correctly:

```bash
rustc --version
cargo --version
```

You should see version information for both commands. If not, visit [rust-lang.org](https://www.rust-lang.org/tools/install) to install Rust.

## Installing Reinhardt Admin

First, install the global tool for project generation:

```bash
cargo install reinhardt-admin
```

## Creating a Project

Navigate to a directory where you'd like to store your code, then run:

```bash
reinhardt-admin startproject polls_project --template-type mtv
cd polls_project
```

This creates a `polls_project` directory with the following structure:

```
polls_project/
├── Cargo.toml
├── README.md
└── src/
    ├── main.rs
    ├── config.rs
    ├── apps.rs
    ├── config/
    │   ├── settings.rs
    │   ├── settings/
    │   │   ├── base.rs
    │   │   ├── local.rs
    │   │   ├── staging.rs
    │   │   └── production.rs
    │   ├── urls.rs
    │   └── apps.rs
    └── bin/
        ├── runserver.rs
        └── manage.rs
```

**Note**: For this tutorial, we're using the **MTV (Model-Template-View)** template which includes templates, forms, and the admin interface.

## Understanding the Project Structure

Let's understand the key elements of the generated project:

- `Cargo.toml` - Configuration file for your project and its dependencies
- `src/main.rs` - The entry point for your application
- `src/config/` - Project configuration
  - `settings/` - Environment-specific settings (base, local, staging, production)
  - `urls.rs` - URL routing configuration
  - `apps.rs` - Installed apps registration
- `src/bin/` - Executable files
  - `manage.rs` - Management commands (equivalent to Django's `manage.py`)
  - `runserver.rs` - Development server

## Creating Your First View

A view in Reinhardt is a function that takes an HTTP request and returns an HTTP response. With Reinhardt, you can use the `#[endpoint]` macro for FastAPI-style dependency injection.

Edit `src/main.rs`:

```rust
use reinhardt::prelude::*;
use reinhardt_macros::endpoint;

// Our first view - returns a simple text response
#[endpoint]
async fn index() -> Result<Response> {
    Response::ok()
        .with_body("Hello, world. You're at the polls index.")
        .with_header("Content-Type", "text/plain")
}
```

This is the simplest view possible in Reinhardt. The `#[endpoint]` macro handles the request parsing and dependency injection automatically.

## Mapping URLs to Views

To call this view, we need to map it to a URL. Reinhardt uses `UnifiedRouter` for efficient O(m) route matching.

Create `src/config/urls.rs`:

```rust
use reinhardt_routers::UnifiedRouter;
use hyper::Method;
use std::sync::Arc;

pub fn url_patterns() -> Arc<UnifiedRouter> {
    let router = UnifiedRouter::new()
        .function("/", Method::GET, crate::index);

    Arc::new(router)
}
```

**Note**: Reinhardt projects generated by `reinhardt-admin startproject` already include proper routing configuration in `src/bin/runserver.rs`. You don't need to manually create a `main.rs` with server setup code.

## Running the Development Server

Now let's run the development server using the `runserver` command:

```bash
cargo run --bin runserver
```

**With auto-reload** (if you have `cargo-watch` installed):

```bash
# Install cargo-watch first (one-time setup)
cargo install cargo-watch

# Enable cargo-watch-reload feature in Cargo.toml
# [dependencies]
# reinhardt-commands = { version = "0.1.0-alpha.1", features = ["cargo-watch-reload"] }

# Run with auto-reload (detects changes and automatically rebuilds)
cargo run --bin runserver

# Optional: Clear screen before each rebuild
cargo run --bin runserver -- --clear
```

You should see output similar to:

```
    Compiling polls_project v0.1.0 (/path/to/polls_project)
     Finished dev [unoptimized + debuginfo] target(s) in 2.34s
      Running `target/debug/runserver`

Reinhardt Development Server
──────────────────────────────────────────────────

  ✓ http://127.0.0.1:8000
  Environment: Debug

Quit the server with CTRL+C
```

Open your web browser and visit `http://127.0.0.1:8000/`. You should see a welcome message.

Congratulations! Your Reinhardt project is now running!

## Understanding What Happened

Let's review what we just did:

1. **Created a view function** (`index`) that returns an HTTP response
2. **Created a URL pattern** that maps the root URL (`""`) to our view
3. **Configured a router** to handle incoming requests
4. **Started a development server** on port 8000

This is the basic request-response cycle in Reinhardt:

```
Browser Request → Server → Router → URL Pattern → View → Response → Browser
```

## Path Function Explained

The `path()` function takes two arguments:

```rust
path("", index)
```

- The first argument is the URL pattern (`""` means the root URL)
- The second argument is the view function to call

You can create more complex patterns:

```rust
path("polls/", polls_index)
path("polls/{id}/", poll_detail)
```

The `{id}` syntax creates a URL parameter that will be passed to your view.

## Creating the Polls App

In Reinhardt, we organize features into apps (similar to Django). Let's create a `polls` app:

```bash
cargo run --bin manage startapp polls --template-type mtv
```

This creates a `polls` directory with the following structure:

```
polls/
├── lib.rs
├── models.rs
├── models/
├── views.rs
├── views/
├── admin.rs
├── urls.rs
└── tests.rs
```

### Creating a View

Edit `polls/views.rs`:

```rust
use reinhardt::prelude::*;
use reinhardt_macros::endpoint;

#[endpoint]
pub async fn index() -> Result<Response> {
    Response::ok()
        .with_body("Hello, world. You're at the polls index.")
        .with_header("Content-Type", "text/plain")
}
```

### Setting Up URL Patterns

Edit `polls/urls.rs`:

```rust
use reinhardt_routers::UnifiedRouter;
use hyper::Method;
use crate::views;

pub fn url_patterns() -> UnifiedRouter {
    UnifiedRouter::new()
        .function("/", Method::GET, views::index)
}
```

### Registering with the Project

Edit `src/config/urls.rs` to include the polls app routes:

```rust
use reinhardt::prelude::*;
use std::sync::Arc;

pub fn url_patterns() -> Arc<UnifiedRouter> {
    let router = UnifiedRouter::new()
        .mount("/polls/", polls::urls::url_patterns());

    Arc::new(router)
}
```

### Registering the App

Edit `src/config/apps.rs`:

```rust
use reinhardt_macros::installed_apps;

installed_apps! {
    polls: "polls",
}

pub fn get_installed_apps() -> Vec<String> {
    InstalledApp::all_apps()
}
```

Restart your server (press Ctrl-C and run `cargo run --bin runserver` again) and visit `http://127.0.0.1:8000/polls/`. You should see the message.

## Adding More Views

Let's add a few more views to make our URL configuration more interesting. Update `polls/views.rs`:

```rust
use reinhardt::prelude::*;
use reinhardt_macros::endpoint;
use reinhardt_http::Request;

#[endpoint]
pub async fn index() -> Result<Response> {
    Response::ok()
        .with_body("Hello, world. You're at the polls index.")
        .with_header("Content-Type", "text/plain")
}

#[endpoint]
pub async fn detail(request: Request) -> Result<Response> {
    // Extract the question_id from path parameters
    let question_id = request.path_params
        .get("question_id")
        .unwrap_or(&"0".to_string());

    Response::ok()
        .with_body(&format!("You're looking at question {}.", question_id))
        .with_header("Content-Type", "text/plain")
}

#[endpoint]
pub async fn results(request: Request) -> Result<Response> {
    let question_id = request.path_params
        .get("question_id")
        .unwrap_or(&"0".to_string());

    Response::ok()
        .with_body(&format!("You're looking at the results of question {}.", question_id))
        .with_header("Content-Type", "text/plain")
}

#[endpoint]
pub async fn vote(request: Request) -> Result<Response> {
    let question_id = request.path_params
        .get("question_id")
        .unwrap_or(&"0".to_string());

    Response::ok()
        .with_body(&format!("You're voting on question {}.", question_id))
        .with_header("Content-Type", "text/plain")
}
```

Update `polls/urls.rs` to wire these views:

```rust
use reinhardt_routers::UnifiedRouter;
use hyper::Method;
use crate::views;

pub fn url_patterns() -> UnifiedRouter {
    UnifiedRouter::new()
        // ex: /polls/
        .function("/", Method::GET, views::index)
        // ex: /polls/5/
        .function("/:question_id", Method::GET, views::detail)
        // ex: /polls/5/results/
        .function("/:question_id/results", Method::GET, views::results)
        // ex: /polls/5/vote/
        .function("/:question_id/vote", Method::POST, views::vote)
}
```

Restart the server and try these URLs:

- `http://127.0.0.1:8000/polls/` - Shows the index
- `http://127.0.0.1:8000/polls/34/` - Shows detail for question 34
- `http://127.0.0.1:8000/polls/34/results/` - Shows results for question 34
- `http://127.0.0.1:8000/polls/34/vote/` - Shows voting form for question 34

## What's Next?

We've created a basic Reinhardt project with URL routing and simple views. In the next tutorial, we'll set up a database and create models to store poll questions and choices.

When you're ready, move on to [Part 2: Models and Database](2-models-and-database.md).

## Summary

In this tutorial, you learned:

- How to create a new Reinhardt project
- How to define views as async functions
- How to map URLs to views using `path()`
- How to run the development server
- How to organize code into modules
- How to extract parameters from URLs

You now have a solid foundation for building Reinhardt applications!