# Part 2: Models and Database

In this tutorial, we'll set up a database and create our first models using
Reinhardt's ORM layer, which is built on SeaQuery v1.0.0-rc.

## Database Setup

Reinhardt supports multiple databases including PostgreSQL, MySQL, and SQLite.
For this tutorial, we'll use SQLite for simplicity.

### Configuring the Database

First, add the database dependencies to `Cargo.toml`:

```toml
[dependencies]
reinhardt = { workspace = true, features = ["database", "orm"] }
tokio = { version = "1", features = ["full"] }
serde = { version = "1.0", features = ["derive"] }
chrono = { version = "0.4", features = ["serde"] }
```

**Note**: Instead of adding `reinhardt-db` directly, we enable the `database`
and `orm` features on the `reinhardt` crate. This provides access to all
database functionality through `reinhardt::prelude::*`.

### Choosing a Database

Reinhardt supports multiple databases. Choose based on your project needs:

| Database | Best For | Feature Flag | Default in `standard` Bundle |
|----------|----------|--------------|------------------------------|
| **PostgreSQL** | Production, complex queries, full-text search | `db-postgres` | ✅ Yes |
| **SQLite** | Development, small projects, prototyping | `db-sqlite` | ❌ No (must add explicitly) |
| **MySQL** | Existing MySQL infrastructure | `db-mysql` | ❌ No (must add explicitly) |
| **CockroachDB** | Distributed databases (uses Postgres protocol) | `db-cockroachdb` | ❌ No (must add explicitly) |

### SQLite Setup (This Tutorial)

For this tutorial, we use SQLite for simplicity. SQLite requires no separate
database server and stores data in a single file.

**Cargo.toml:**

```toml
[dependencies]
reinhardt = { version = "0.1.0-alpha.1", default-features = false, features = ["standard", "db-sqlite"] }
```

**settings/base.toml:**

```toml
[database]
engine = "sqlite"
name = "polls.db"  # Database file path
```

### PostgreSQL Setup (Recommended for Production)

PostgreSQL is included by default with the `standard` bundle and is recommended
for production use.

**Cargo.toml:**

```toml
[dependencies]
reinhardt = { version = "0.1.0-alpha.1", features = ["standard"] }
# db-postgres is automatically included with "standard"
```

**settings/base.toml:**

```toml
[database]
engine = "postgresql"
host = "localhost"
port = 5432
name = "mydb"
user = "postgres"
password = "postgres"
```

**Docker setup (for local development):**

```bash
docker run --name postgres -e POSTGRES_PASSWORD=postgres -p 5432:5432 -d postgres:16
```

### MySQL Setup

**Cargo.toml:**

```toml
[dependencies]
reinhardt = { version = "0.1.0-alpha.1", default-features = false, features = ["standard", "db-mysql"] }
```

**settings/base.toml:**

```toml
[database]
engine = "mysql"
host = "localhost"
port = 3306
name = "mydb"
user = "root"
password = "root"
```

For more database options and configurations, see the [Feature Flags Guide](../../../FEATURE_FLAGS.md).

### Configuration for This Tutorial

Create or update `settings/base.toml` with SQLite configuration:

```toml
debug = true
secret_key = "your-secret-key-for-development"

[database]
engine = "sqlite"
name = "polls.db"
```

**Note**: Reinhardt projects generated by `reinhardt-admin startproject` already
include settings configuration. The database connection is automatically
established when you run `cargo run --bin runserver`.

## Creating Models

A model is the single, definitive source of information about your data. It
contains the essential fields and behaviors of the data you're storing.

Let's create two models for our polls application:

- **Question** - Stores poll questions with their publication date
- **Choice** - Stores choices for each question with their vote counts

Create `polls/models.rs`:

```rust
use serde::{Deserialize, Serialize};
use chrono::{DateTime, Utc};
use reinhardt::prelude::*;

#[model(app_label = "polls", table_name = "polls_question")]
#[derive(Serialize, Deserialize)]
pub struct Question {
    #[field(primary_key = true)]
    pub id: Option<i64>,

    #[field(max_length = 200)]
    pub question_text: String,

    #[field(auto_now_add = true)]
    pub pub_date: DateTime<Utc>,
}

#[model(app_label = "polls", table_name = "polls_choice")]
#[derive(Serialize, Deserialize)]
pub struct Choice {
    #[field(primary_key = true)]
    pub id: Option<i64>,

    #[field(foreign_key = "Question")]
    pub question_id: i64,

    #[field(max_length = 200)]
    pub choice_text: String,

    #[field(default = 0)]
    pub votes: i32,
}

impl Question {
    /// Check if this question was published recently (within the last day)
    pub fn was_published_recently(&self) -> bool {
        let now = Utc::now();
        let one_day_ago = now - chrono::Duration::days(1);
        self.pub_date >= one_day_ago && self.pub_date <= now
    }
}
```

These models define:

- **Question**: Has an auto-incrementing ID (Option<i64>), question text, and
  publication date
- **Choice**: Has an ID, references a Question (via `question_id`), choice text,
  and vote count

**Note**: `id` fields are `Option<i64>` because they're `None` before insertion
and `Some(id)` after being saved to the database.

> **Important**: The `#[model(...)]` macro automatically derives the `Model` trait
> and generates all necessary CRUD methods. You don't need to add `#[derive(Model)]`
> manually. Only add `#[derive(Serialize, Deserialize)]` for serde support if needed.

## Understanding Fields

Let's break down the field types:

- `Option<i64>` - Optional integer field for IDs (auto-generated)
- `i64` - Integer field for foreign keys
- `String` - Character field for text
- `DateTime<Utc>` - DateTime field for timestamps
- `i32` - Integer field for vote counts

### Field Attributes

The `#[field(...)]` attributes provide metadata for the ORM:

- `primary_key = true` - Marks the field as the primary key
- `max_length = 200` - Sets maximum length for string fields
- `auto_now_add = true` - Automatically sets timestamp on creation
- `default = 0` - Sets default value for the field
- `foreign_key = "ModelName"` - Defines a foreign key relationship

## Model Macro Benefits

The `#[model(...)]` macro automatically generates:

1. **Type-Safe Field Accessors**: Access fields with type safety
   ```rust
   Question::field_id()           // Returns FieldRef<Question, Option<i64>>
   Question::field_question_text() // Returns FieldRef<Question, String>
   Question::field_pub_date()     // Returns FieldRef<Question, DateTime<Utc>>
   ```

2. **CRUD Methods**: Basic database operations
   ```rust
   question.save(&conn).await?;           // Insert or update
   question.delete(&conn).await?;         // Delete from database
   question.refresh_from_db(&conn).await?; // Reload from database
   ```

3. **QuerySet Methods**: Type-safe querying
   ```rust
   Question::objects()
       .filter(Question::field_pub_date().gte(Utc::now()))
       .all(&conn)
       .await?;
   ```

These methods are generated at compile time, providing zero-cost abstractions
with full type safety.

## Creating the Database Schema with Migrations

Instead of manually creating SQL files, Reinhardt provides Django-style
automatic migration generation:

```bash
cargo run --bin manage makemigrations
```

This command analyzes your models and automatically generates migration files in
`migrations/polls/`. The generated migration will create tables with proper
schema.

To apply the migrations:

```bash
cargo run --bin manage migrate
```

You should see output like:

```
Running migrations:
  Applying polls.0001_initial... OK
```

**What happened?**

1. `makemigrations` detected your `Question` and `Choice` models
2. Generated Rust migration code in `migrations/polls/_0001_initial.rs`
3. `migrate` applied these migrations to create the database tables

## Playing with the Database API

Now let's use Reinhardt's ORM to interact with the database. With
`#[derive(Model)]`, many common operations are automatically available. Here are
some examples:

### Creating Records

```rust
use reinhardt::prelude::*;
use chrono::Utc;

// Create a new question
let mut question = Question {
    id: None,
    question_text: "What's your favorite programming language?".to_string(),
    pub_date: Utc::now(),
};

// Save to database (generated by Model macro)
question.save(&conn).await?;
println!("Created question with ID: {:?}", question.id);
```

### Querying Records

```rust
// Get all questions ordered by publication date (using type-safe field accessors)
let questions = Question::objects()
    .order_by(Question::field_pub_date(), false)  // false = DESC
    .all(&conn)
    .await?;

// Filter questions by date
let recent_questions = Question::objects()
    .filter(Question::field_pub_date().gte(Utc::now() - chrono::Duration::days(7)))
    .all(&conn)
    .await?;

// Get a specific question by ID
let question = Question::objects()
    .filter(Question::field_id().eq(1))
    .first(&conn)
    .await?;
```

### Relationships

```rust
// Get all choices for a question
let choices = Choice::objects()
    .filter(Choice::field_question_id().eq(question.id.unwrap()))
    .all(&conn)
    .await?;
```

### Updating Records

```rust
// Update using F expressions (atomic database operations)
Choice::objects()
    .filter(Choice::field_id().eq(choice_id))
    .update()
    .set(Choice::field_votes(), F::new(Choice::field_votes()) + 1)
    .execute(&conn)
    .await?;
```

### Deleting Records

```rust
// Delete a record (generated by Model macro)
question.delete(&conn).await?;
```

### Custom Helper Methods

You can still add custom methods to your models:

```rust
impl Question {
    /// Check if this question was published recently (within the last day)
    pub fn was_published_recently(&self) -> bool {
        let now = Utc::now();
        let one_day_ago = now - chrono::Duration::days(1);
        self.pub_date >= one_day_ago && self.pub_date <= now
    }

    /// Get all choices for this question
    pub async fn choices(
        &self,
        conn: &DatabaseConnection
    ) -> Result<Vec<Choice>, Box<dyn std::error::Error>> {
        let question_id = self.id.ok_or("Question must be saved first")?;
        Choice::objects()
            .filter(Choice::field_question_id().eq(question_id))
            .all(conn)
            .await
    }
}
```

**Key Points:**

- `save()`, `delete()`, and `refresh_from_db()` are automatically generated by
  `#[model(...)]`
- Use `Model::objects()` to start building queries
- Use type-safe field accessors like `Question::field_id()` instead of string
  literals
- Use `F` expressions for atomic database updates (e.g., incrementing counters)

## Testing the Models

Let's create proper tests using rstest and TestContainers. First, add test
dependencies to `Cargo.toml`:

```toml
[dev-dependencies]
rstest = "0.22"
testcontainers = "0.23"
tokio = { version = "1", features = ["full"] }
```

Create `polls/tests.rs`:

```rust
use super::models::{Question, Choice};
use reinhardt::prelude::*;
use reinhardt::test::fixtures::*;
use chrono::Utc;
use rstest::*;
use testcontainers::ContainerAsync;
use testcontainers_modules::postgres::Postgres;

#[fixture]
async fn postgres_db() -> (ContainerAsync<Postgres>, Arc<DatabaseConnection>) {
    let postgres = Postgres::default()
        .start()
        .await
        .expect("Failed to start PostgreSQL");

    let port = postgres.get_host_port_ipv4(5432).await.unwrap();
    let url = format!("postgres://postgres:postgres@localhost:{}/test_db", port);

    let conn = DatabaseConnection::connect(&url).await.unwrap();
    let conn = Arc::new(conn);

    // Run migrations
    run_migrations(&conn).await.unwrap();

    (postgres, conn)
}

#[rstest]
#[tokio::test]
async fn test_create_question_and_choices(
    #[future] postgres_db: (ContainerAsync<Postgres>, Arc<DatabaseConnection>)
) {
    let (_container, conn) = postgres_db.await;

    // Create a question
    let mut question = Question {
        id: None,
        question_text: "What's your favorite programming language?".to_string(),
        pub_date: Utc::now(),
    };

    question.save(&conn).await.unwrap();
    assert!(question.id.is_some());

    // Add some choices
    let question_id = question.id.unwrap();

    let mut rust_choice = Choice {
        id: None,
        question_id,
        choice_text: "Rust".to_string(),
        votes: 0,
    };
    rust_choice.save(&conn).await.unwrap();

    let mut python_choice = Choice {
        id: None,
        question_id,
        choice_text: "Python".to_string(),
        votes: 0,
    };
    python_choice.save(&conn).await.unwrap();

    // Retrieve the question
    let retrieved_question = Question::objects()
        .filter(Question::field_id().eq(question_id))
        .first(&conn)
        .await
        .unwrap()
        .expect("Question not found");

    assert_eq!(retrieved_question.question_text, question.question_text);
    assert!(retrieved_question.was_published_recently());

    // Get choices
    let choices = retrieved_question.choices(&conn).await.unwrap();
    assert_eq!(choices.len(), 2);

    // Container is automatically cleaned up when dropped
}

#[rstest]
#[tokio::test]
async fn test_increment_votes(
    #[future] postgres_db: (ContainerAsync<Postgres>, Arc<DatabaseConnection>)
) {
    let (_container, conn) = postgres_db.await;

    // Create question and choice
    let mut question = Question {
        id: None,
        question_text: "Test question".to_string(),
        pub_date: Utc::now(),
    };
    question.save(&conn).await.unwrap();

    let mut choice = Choice {
        id: None,
        question_id: question.id.unwrap(),
        choice_text: "Test choice".to_string(),
        votes: 0,
    };
    choice.save(&conn).await.unwrap();
    let choice_id = choice.id.unwrap();

    // Increment votes using F expression
    Choice::objects()
        .filter(Choice::field_id().eq(choice_id))
        .update()
        .set(Choice::field_votes(), F::new(Choice::field_votes()) + 1)
        .execute(&conn)
        .await
        .unwrap();

    // Verify votes incremented
    let updated_choice = Choice::objects()
        .filter(Choice::field_id().eq(choice_id))
        .first(&conn)
        .await
        .unwrap()
        .expect("Choice not found");

    assert_eq!(updated_choice.votes, 1);
}
```

**Key Testing Features:**

1. **rstest fixtures**: Reusable test setup with `#[fixture]`
2. **TestContainers**: Real PostgreSQL database for each test
3. **Automatic cleanup**: Containers are destroyed after tests
4. **Type-safe queries**: Using field accessors in assertions
5. **F expressions**: Testing atomic update operations

Run the test:

```bash
cargo test --package polls
```

## Understanding Dependency Injection

Reinhardt provides FastAPI-style dependency injection via the `#[inject]`
attribute. This eliminates boilerplate code for accessing shared resources like
database connections.

**Without DI (manual approach):**

```rust
async fn index(req: Request) -> Result<Response> {
    // Manually extract from request extensions
    let conn = req.extensions
        .get::<Arc<DatabaseConnection>>()
        .ok_or("Database not configured")?;

    let questions = Question::all(conn).await?;
    // ...
}
```

**With DI (automatic approach):**

```rust
#[get("/", name = "index")]
async fn index(
    #[inject] conn: Arc<DatabaseConnection>,  // Automatically injected!
) -> Result<Response> {
    let questions = Question::all(&conn).await?;
    // ...
}
```

**How it works:**

1. **Registration**: The server registers `DatabaseConnection` at startup
2. **Injection**: The `#[inject]` attribute tells Reinhardt to inject the dependency
3. **Type safety**: Compile error if the dependency type isn't registered

**Caching behavior:**

- `#[inject]` - Cached (default) - Reuses the same instance across requests
- `#[inject(cache = false)]` - Non-cached - Creates a new instance per request

**Benefits:**

- **Less boilerplate** - No manual extraction from request extensions
- **Type-safe** - Compiler verifies dependency types
- **Testable** - Easy to mock dependencies in tests
- **Flexible** - Support for both cached and non-cached dependencies

For more details on dependency injection, see the [Dependency Injection Guide](../../di/README.md).

## Using the ORM in Views

Now that we have models, let's use them in views. Update `polls/views.rs`:

```rust
use reinhardt::prelude::*;
use reinhardt::get;
use reinhardt::di::Depends;
use reinhardt::db::backends::DatabaseConnection;
use std::sync::Arc;
use crate::models::Question;

#[get("/", name = "index")]
pub async fn index(
    #[inject] conn: Arc<DatabaseConnection>,
) -> Result<Response> {
    let questions = Question::all(&conn).await?;

    Response::ok()
        .with_json(&questions)
}

#[get("/:id", name = "detail")]
pub async fn detail(
    request: Request,
    #[inject] conn: Arc<DatabaseConnection>,
) -> Result<Response> {
    let question_id: i64 = request.path_params
        .get("question_id")
        .ok_or("Missing question_id")?
        .parse()?;

    let question = Question::get(&conn, question_id)
        .await?
        .ok_or("Question not found")?;

    let choices = question.choices(&conn).await?;

    let data = serde_json::json!({
        "question": question,
        "choices": choices,
    });

    Response::ok()
        .with_json(&data)
}
```

The `#[inject]` attribute automatically provides the database connection from
the application's dependency injection container.

## Introduction to the Reinhardt Admin

The Reinhardt admin is an automatically-generated interface for managing your
data. Let's enable it for our models.

Add the admin dependency to `Cargo.toml`:

```toml
[dependencies]
reinhardt = { version = "0.1.0-alpha.1", features = ["standard", "admin"] }
```

Register your models in `polls/admin.rs`:

```rust
use reinhardt::contrib::admin::ModelAdmin;
use crate::models::{Question, Choice};

pub fn register_admin(admin_site: &mut AdminSite) {
    admin_site.register::<Question>(ModelAdmin::default());
    admin_site.register::<Choice>(ModelAdmin::default());
}
```

The admin interface will be covered in more detail in Part 7, but for now, know
that you can access it at `http://127.0.0.1:8000/admin/` after creating a
superuser.

## Summary

In this tutorial, you learned:

- How to configure a database connection using settings files
- How to define models with Reinhardt's ORM
- How to use automatic migration generation (`makemigrations` and `migrate`)
- How to perform CRUD operations using QuerySet API
- How to use dependency injection to access the database in views
- The relationship between models (foreign keys)
- How to query the database using the ORM API (not raw SQL)

## What's Next?

Now that our models are set up, we can start building views that display this
data to users. In the next tutorial, we'll create views that show poll questions
and their details.

Continue to [Part 3: Views and URLs](3-views-and-urls.md).
