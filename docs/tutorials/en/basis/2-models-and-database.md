# Part 2: Models and Database

In this tutorial, we'll set up a database and create our first models using Reinhardt's ORM layer, which is built on SeaQuery v1.0.0-rc1.

## Database Setup

Reinhardt supports multiple databases including PostgreSQL, MySQL, and SQLite. For this tutorial, we'll use SQLite for simplicity.

### Configuring the Database

First, add the database dependencies to `Cargo.toml`:

```toml
[dependencies]
reinhardt = { version = "0.1.0-alpha.1", features = ["standard"] }
reinhardt-db = { workspace = true }
tokio = { version = "1", features = ["full"] }
serde = { version = "1.0", features = ["derive"] }
chrono = { version = "0.4", features = ["serde"] }
```

Create or update `settings/base.toml` with your database configuration:

```toml
debug = true
secret_key = "your-secret-key-for-development"

[database]
engine = "sqlite"
name = "polls.db"
```

**Note**: Reinhardt projects generated by `reinhardt-admin startproject` already include settings configuration. The database connection is automatically established when you run `cargo run --bin runserver`.

## Creating Models

A model is the single, definitive source of information about your data. It contains the essential fields and behaviors of the data you're storing.

Let's create two models for our polls application:

- **Question** - Stores poll questions with their publication date
- **Choice** - Stores choices for each question with their vote counts

Create `polls/models.rs`:

```rust
use serde::{Deserialize, Serialize};
use chrono::{DateTime, Utc};
use reinhardt_db::orm::Model;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Question {
    pub id: Option<i64>,
    pub question_text: String,
    pub pub_date: DateTime<Utc>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Choice {
    pub id: Option<i64>,
    pub question_id: i64,
    pub choice_text: String,
    pub votes: i32,
}

impl Question {
    /// Check if this question was published recently (within the last day)
    pub fn was_published_recently(&self) -> bool {
        let now = Utc::now();
        let one_day_ago = now - chrono::Duration::days(1);
        self.pub_date >= one_day_ago && self.pub_date <= now
    }
}
```

These models define:

- **Question**: Has an auto-incrementing ID (Option<i64>), question text, and publication date
- **Choice**: Has an ID, references a Question (via `question_id`), choice text, and vote count

**Note**: `id` fields are `Option<i64>` because they're `None` before insertion and `Some(id)` after being saved to the database.

## Understanding Fields

Let's break down the field types:

- `Option<i64>` - Optional integer field for IDs (auto-generated)
- `i64` - Integer field for foreign keys
- `String` - Character field for text
- `DateTime<Utc>` - DateTime field for timestamps
- `i32` - Integer field for vote counts

## Creating the Database Schema with Migrations

Instead of manually creating SQL files, Reinhardt provides Django-style automatic migration generation:

```bash
cargo run --bin manage makemigrations
```

This command analyzes your models and automatically generates migration files in `migrations/polls/`. The generated migration will create tables with proper schema.

To apply the migrations:

```bash
cargo run --bin manage migrate
```

You should see output like:

```
Running migrations:
  Applying polls.0001_initial... OK
```

**What happened?**

1. `makemigrations` detected your `Question` and `Choice` models
2. Generated Rust migration code in `migrations/polls/_0001_initial.rs`
3. `migrate` applied these migrations to create the database tables

## Playing with the Database API

Now let's use Reinhardt's ORM to interact with the database. Update `polls/models.rs`:

```rust
use serde::{Deserialize, Serialize};
use chrono::{DateTime, Utc};
use reinhardt_db::orm::{QuerySet, Model};
use reinhardt_db::backends::DatabaseConnection;
use std::sync::Arc;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Question {
    pub id: Option<i64>,
    pub question_text: String,
    pub pub_date: DateTime<Utc>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Choice {
    pub id: Option<i64>,
    pub question_id: i64,
    pub choice_text: String,
    pub votes: i32,
}

impl Question {
    /// Create a new question
    pub async fn create(
        conn: &DatabaseConnection,
        question_text: String,
        pub_date: DateTime<Utc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        let mut question = Self {
            id: None,
            question_text,
            pub_date,
        };

        question.save(conn).await?;
        Ok(question)
    }

    /// Get all questions ordered by publication date
    pub async fn all(
        conn: &DatabaseConnection
    ) -> Result<Vec<Self>, Box<dyn std::error::Error>> {
        QuerySet::<Self>::all()
            .order_by("pub_date", false) // false = DESC
            .execute(conn)
            .await
    }

    /// Get a question by ID
    pub async fn get(
        conn: &DatabaseConnection,
        id: i64
    ) -> Result<Option<Self>, Box<dyn std::error::Error>> {
        QuerySet::<Self>::filter()
            .eq("id", id)
            .first(conn)
            .await
    }

    /// Get all choices for this question
    pub async fn choices(
        &self,
        conn: &DatabaseConnection
    ) -> Result<Vec<Choice>, Box<dyn std::error::Error>> {
        let question_id = self.id.ok_or("Question must be saved first")?;
        Choice::filter_by_question(conn, question_id).await
    }

    /// Check if this question was published recently (within the last day)
    pub fn was_published_recently(&self) -> bool {
        let now = Utc::now();
        let one_day_ago = now - chrono::Duration::days(1);
        self.pub_date >= one_day_ago && self.pub_date <= now
    }
}

impl Choice {
    /// Create a new choice
    pub async fn create(
        conn: &DatabaseConnection,
        question_id: i64,
        choice_text: String,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        let mut choice = Self {
            id: None,
            question_id,
            choice_text,
            votes: 0,
        };

        choice.save(conn).await?;
        Ok(choice)
    }

    /// Get all choices for a question
    pub async fn filter_by_question(
        conn: &DatabaseConnection,
        question_id: i64,
    ) -> Result<Vec<Self>, Box<dyn std::error::Error>> {
        QuerySet::<Self>::filter()
            .eq("question_id", question_id)
            .execute(conn)
            .await
    }

    /// Increment vote count
    pub async fn increment_votes(
        &mut self,
        conn: &DatabaseConnection
    ) -> Result<(), Box<dyn std::error::Error>> {
        self.votes += 1;
        self.save(conn).await
    }
}
```

## Testing the Models

Let's create a simple test script. Create `polls/tests.rs`:

```rust
use super::models::{Question, Choice};
use reinhardt_db::backends::DatabaseConnection;
use chrono::Utc;
use std::sync::Arc;

#[tokio::test]
async fn test_create_question_and_choices() {
    // Setup database connection
    let conn = DatabaseConnection::connect("sqlite::memory:").await.unwrap();

    // Run migrations (for test database)
    // Note: In real tests, use TestContainers for isolation

    // Create a question
    let question = Question::create(
        &conn,
        "What's your favorite programming language?".to_string(),
        Utc::now(),
    )
    .await
    .unwrap();

    assert!(question.id.is_some());
    println!("Created question with ID: {:?}", question.id);

    // Add some choices
    let question_id = question.id.unwrap();
    Choice::create(&conn, question_id, "Rust".to_string()).await.unwrap();
    Choice::create(&conn, question_id, "Python".to_string()).await.unwrap();
    Choice::create(&conn, question_id, "JavaScript".to_string()).await.unwrap();

    // Retrieve the question
    let retrieved_question = Question::get(&conn, question_id)
        .await
        .unwrap()
        .expect("Question not found");

    assert_eq!(retrieved_question.question_text, question.question_text);
    println!("Question: {}", retrieved_question.question_text);
    println!("Published: {}", retrieved_question.pub_date);
    println!("Recently published? {}", retrieved_question.was_published_recently());

    // Get choices
    let choices = retrieved_question.choices(&conn).await.unwrap();
    assert_eq!(choices.len(), 3);

    println!("Choices:");
    for choice in choices {
        println!("  - {} (votes: {})", choice.choice_text, choice.votes);
    }
}
```

Run the test:

```bash
cargo test --package polls
```

## Using the ORM in Views

Now that we have models, let's use them in views. Update `polls/views.rs`:

```rust
use reinhardt::prelude::*;
use reinhardt_macros::endpoint;
use reinhardt_di::Depends;
use reinhardt_db::backends::DatabaseConnection;
use std::sync::Arc;
use crate::models::Question;

#[endpoint]
pub async fn index(
    #[inject] conn: Arc<DatabaseConnection>,
) -> Result<Response> {
    let questions = Question::all(&conn).await?;

    Response::ok()
        .with_json(&questions)
}

#[endpoint]
pub async fn detail(
    request: Request,
    #[inject] conn: Arc<DatabaseConnection>,
) -> Result<Response> {
    let question_id: i64 = request.path_params
        .get("question_id")
        .ok_or("Missing question_id")?
        .parse()?;

    let question = Question::get(&conn, question_id)
        .await?
        .ok_or("Question not found")?;

    let choices = question.choices(&conn).await?;

    let data = serde_json::json!({
        "question": question,
        "choices": choices,
    });

    Response::ok()
        .with_json(&data)
}
```

The `#[inject]` attribute automatically provides the database connection from the application's dependency injection container.

## Introduction to the Reinhardt Admin

The Reinhardt admin is an automatically-generated interface for managing your data. Let's enable it for our models.

Add the admin dependency to `Cargo.toml`:

```toml
[dependencies]
reinhardt = { version = "0.1.0-alpha.1", features = ["standard", "admin"] }
```

Register your models in `polls/admin.rs`:

```rust
use reinhardt_contrib::admin::ModelAdmin;
use crate::models::{Question, Choice};

pub fn register_admin(admin_site: &mut AdminSite) {
    admin_site.register::<Question>(ModelAdmin::default());
    admin_site.register::<Choice>(ModelAdmin::default());
}
```

The admin interface will be covered in more detail in Part 7, but for now, know that you can access it at `http://127.0.0.1:8000/admin/` after creating a superuser.

## Summary

In this tutorial, you learned:

- How to configure a database connection using settings files
- How to define models with Reinhardt's ORM
- How to use automatic migration generation (`makemigrations` and `migrate`)
- How to perform CRUD operations using QuerySet API
- How to use dependency injection to access the database in views
- The relationship between models (foreign keys)
- How to query the database using the ORM API (not raw SQL)

## What's Next?

Now that our models are set up, we can start building views that display this data to users. In the next tutorial, we'll create views that show poll questions and their details.

Continue to [Part 3: Views and URLs](3-views-and-urls.md).
