// Preact Render to String - SSR for Preact
// This is a simplified version for QuickJS SSR
// Original: https://github.com/preactjs/preact-render-to-string (MIT License)

var preactRenderToString = (function() {
	'use strict';

	// HTML entity encoding
	var ENCODED_ENTITIES = /["&<]/g;
	var ENCODE_MAP = {
		'"': '&quot;',
		'&': '&amp;',
		'<': '&lt;'
	};

	function encodeEntities(str) {
		if (typeof str !== 'string') return str;
		return str.replace(ENCODED_ENTITIES, function(char) {
			return ENCODE_MAP[char] || char;
		});
	}

	// Void elements (self-closing)
	var VOID_ELEMENTS = {
		area: true, base: true, br: true, col: true, embed: true,
		hr: true, img: true, input: true, link: true, meta: true,
		param: true, source: true, track: true, wbr: true
	};

	// Boolean attributes
	var BOOLEAN_ATTRS = {
		checked: true, disabled: true, hidden: true, readonly: true,
		required: true, selected: true, autofocus: true, autoplay: true,
		controls: true, loop: true, muted: true, multiple: true, open: true
	};

	// CSS property to attribute name mapping
	var STYLE_REGEX = /([A-Z])/g;

	function styleToString(style) {
		if (typeof style === 'string') return style;
		if (!style || typeof style !== 'object') return '';

		var result = '';
		for (var key in style) {
			if (style.hasOwnProperty(key)) {
				var value = style[key];
				if (value != null && value !== '') {
					// Convert camelCase to kebab-case
					var cssKey = key.replace(STYLE_REGEX, '-$1').toLowerCase();
					result += cssKey + ':' + value + ';';
				}
			}
		}
		return result;
	}

	// Render virtual DOM node to HTML string
	function render(vnode, context, options) {
		if (vnode == null || typeof vnode === 'boolean') {
			return '';
		}

		// Handle primitives (string, number)
		if (typeof vnode === 'string' || typeof vnode === 'number') {
			return encodeEntities(String(vnode));
		}

		// Handle arrays
		if (Array.isArray(vnode)) {
			var result = '';
			for (var i = 0; i < vnode.length; i++) {
				result += render(vnode[i], context, options);
			}
			return result;
		}

		// Handle virtual DOM nodes
		var type = vnode.type;
		var props = vnode.props || {};

		// Handle function components
		if (typeof type === 'function') {
			// Fragment
			if (type === preact.Fragment || type.name === 'Fragment') {
				return render(props.children, context, options);
			}

			// Component
			var componentResult = type(props, context);
			return render(componentResult, context, options);
		}

		// Handle HTML elements
		if (typeof type === 'string') {
			var html = '<' + type;

			// Render attributes
			for (var key in props) {
				if (key === 'children' || key === 'key' || key === 'ref') continue;
				if (key === 'dangerouslySetInnerHTML') continue;

				var value = props[key];
				if (value == null || value === false) continue;

				// Event handlers are skipped in SSR
				if (key.startsWith('on') && typeof value === 'function') continue;

				// Handle className -> class
				if (key === 'className') key = 'class';
				if (key === 'htmlFor') key = 'for';

				// Handle style object
				if (key === 'style' && typeof value === 'object') {
					value = styleToString(value);
				}

				// Boolean attributes
				if (BOOLEAN_ATTRS[key]) {
					if (value === true) {
						html += ' ' + key;
					}
				} else {
					html += ' ' + key + '="' + encodeEntities(String(value)) + '"';
				}
			}

			// Void elements (self-closing)
			if (VOID_ELEMENTS[type]) {
				return html + ' />';
			}

			html += '>';

			// Handle dangerouslySetInnerHTML
			if (props.dangerouslySetInnerHTML) {
				html += props.dangerouslySetInnerHTML.__html || '';
			} else {
				// Render children
				html += render(props.children, context, options);
			}

			html += '</' + type + '>';
			return html;
		}

		return '';
	}

	return {
		render: render,
		renderToString: render,
		renderToStaticMarkup: render
	};
})();

// Expose globally
if (typeof globalThis !== 'undefined') {
	globalThis.preactRenderToString = preactRenderToString;
}
