// Generated by `wit-bindgen` 0.41.0. DO NOT EDIT!
// Options used:
//   * runtime_path: "wit_bindgen_rt"
#[rustfmt::skip]
#[allow(dead_code, clippy::all)]
pub mod reinhardt {
    pub mod dentdelion {
        /// Common types shared between host and plugin interfaces.
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod types {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            /// Plugin metadata describing the plugin's identity and properties.
            #[derive(Clone)]
            pub struct PluginMetadata {
                /// Unique identifier for the plugin (e.g., "auth-delion")
                pub name: _rt::String,
                /// Semantic version string (e.g., "1.0.0")
                pub version: _rt::String,
                /// Human-readable description
                pub description: Option<_rt::String>,
                /// List of authors
                pub authors: _rt::Vec<_rt::String>,
                /// SPDX license identifier
                pub license: Option<_rt::String>,
                /// Repository URL
                pub repository: Option<_rt::String>,
                /// Homepage URL
                pub homepage: Option<_rt::String>,
            }
            impl ::core::fmt::Debug for PluginMetadata {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("PluginMetadata")
                        .field("name", &self.name)
                        .field("version", &self.version)
                        .field("description", &self.description)
                        .field("authors", &self.authors)
                        .field("license", &self.license)
                        .field("repository", &self.repository)
                        .field("homepage", &self.homepage)
                        .finish()
                }
            }
            /// Plugin capabilities that define what a plugin can provide.
            /// Note: Models capability is NOT available for WASM plugins.
            #[derive(Clone)]
            pub enum Capability {
                /// HTTP middleware
                Middleware,
                /// CLI commands
                Commands,
                /// REST API ViewSets
                ViewSets,
                /// Custom signals
                Signals,
                /// DI service registration
                Services,
                /// Authentication backends
                Auth,
                /// Template engines
                Templates,
                /// Static file handlers
                StaticFiles,
                /// URL routing
                Routing,
                /// Signal receivers
                SignalReceivers,
                /// HTTP handlers
                Handlers,
                /// Network/HTTP access for external requests
                NetworkAccess,
                /// Database access for SQL queries
                DatabaseAccess,
                /// Custom capability defined by the plugin
                Custom(_rt::String),
            }
            impl ::core::fmt::Debug for Capability {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        Capability::Middleware => {
                            f.debug_tuple("Capability::Middleware").finish()
                        }
                        Capability::Commands => {
                            f.debug_tuple("Capability::Commands").finish()
                        }
                        Capability::ViewSets => {
                            f.debug_tuple("Capability::ViewSets").finish()
                        }
                        Capability::Signals => {
                            f.debug_tuple("Capability::Signals").finish()
                        }
                        Capability::Services => {
                            f.debug_tuple("Capability::Services").finish()
                        }
                        Capability::Auth => f.debug_tuple("Capability::Auth").finish(),
                        Capability::Templates => {
                            f.debug_tuple("Capability::Templates").finish()
                        }
                        Capability::StaticFiles => {
                            f.debug_tuple("Capability::StaticFiles").finish()
                        }
                        Capability::Routing => {
                            f.debug_tuple("Capability::Routing").finish()
                        }
                        Capability::SignalReceivers => {
                            f.debug_tuple("Capability::SignalReceivers").finish()
                        }
                        Capability::Handlers => {
                            f.debug_tuple("Capability::Handlers").finish()
                        }
                        Capability::NetworkAccess => {
                            f.debug_tuple("Capability::NetworkAccess").finish()
                        }
                        Capability::DatabaseAccess => {
                            f.debug_tuple("Capability::DatabaseAccess").finish()
                        }
                        Capability::Custom(e) => {
                            f.debug_tuple("Capability::Custom").field(e).finish()
                        }
                    }
                }
            }
            /// Error information returned from plugin operations.
            #[derive(Clone)]
            pub struct PluginError {
                /// Error code (0 = success, non-zero = error)
                pub code: u32,
                /// Human-readable error message
                pub message: _rt::String,
                /// Optional additional details
                pub details: Option<_rt::String>,
            }
            impl ::core::fmt::Debug for PluginError {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("PluginError")
                        .field("code", &self.code)
                        .field("message", &self.message)
                        .field("details", &self.details)
                        .finish()
                }
            }
            impl ::core::fmt::Display for PluginError {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    write!(f, "{:?}", self)
                }
            }
            impl std::error::Error for PluginError {}
            /// HTTP response from host API calls.
            #[derive(Clone)]
            pub struct HttpResponse {
                /// HTTP status code
                pub status: u16,
                /// Response headers
                pub headers: _rt::Vec<(_rt::String, _rt::String)>,
                /// Response body
                pub body: _rt::Vec<u8>,
            }
            impl ::core::fmt::Debug for HttpResponse {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("HttpResponse")
                        .field("status", &self.status)
                        .field("headers", &self.headers)
                        .field("body", &self.body)
                        .finish()
                }
            }
        }
        /// Host API - Functions provided by the Reinhardt host to plugins.
        ///
        /// These functions allow plugins to interact with the host environment
        /// in a controlled and sandboxed manner.
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod host {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            pub type PluginError = super::super::super::reinhardt::dentdelion::types::PluginError;
            pub type HttpResponse = super::super::super::reinhardt::dentdelion::types::HttpResponse;
            #[allow(unused_unsafe, clippy::all)]
            /// ===== Configuration Access =====
            /// Get a configuration value by key.
            /// Returns MessagePack-serialized ConfigValue.
            pub fn get_config(key: &str) -> Option<_rt::Vec<u8>> {
                unsafe {
                    #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                    #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 3 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 3
                            * ::core::mem::size_of::<*const u8>()],
                    );
                    let vec0 = key;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "reinhardt:dentdelion/host@0.1.0")]
                    unsafe extern "C" {
                        #[link_name = "get-config"]
                        fn wit_import2(_: *mut u8, _: usize, _: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import2(_: *mut u8, _: usize, _: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import2(ptr0.cast_mut(), len0, ptr1) };
                    let l3 = i32::from(*ptr1.add(0).cast::<u8>());
                    let result7 = match l3 {
                        0 => None,
                        1 => {
                            let e = {
                                let l4 = *ptr1
                                    .add(::core::mem::size_of::<*const u8>())
                                    .cast::<*mut u8>();
                                let l5 = *ptr1
                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>();
                                let len6 = l5;
                                _rt::Vec::from_raw_parts(l4.cast(), len6, len6)
                            };
                            Some(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                    };
                    result7
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Set a configuration value.
            /// Value is MessagePack-serialized ConfigValue.
            /// Returns error if the key is read-only or invalid.
            pub fn set_config(key: &str, value: &[u8]) -> Result<(), PluginError> {
                unsafe {
                    #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                    #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 7 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 7
                            * ::core::mem::size_of::<*const u8>()],
                    );
                    let vec0 = key;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    let vec1 = value;
                    let ptr1 = vec1.as_ptr().cast::<u8>();
                    let len1 = vec1.len();
                    let ptr2 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "reinhardt:dentdelion/host@0.1.0")]
                    unsafe extern "C" {
                        #[link_name = "set-config"]
                        fn wit_import3(
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        );
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import3(
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                    ) {
                        unreachable!()
                    }
                    unsafe {
                        wit_import3(ptr0.cast_mut(), len0, ptr1.cast_mut(), len1, ptr2)
                    };
                    let l4 = i32::from(*ptr2.add(0).cast::<u8>());
                    let result13 = match l4 {
                        0 => {
                            let e = ();
                            Ok(e)
                        }
                        1 => {
                            let e = {
                                let l5 = *ptr2
                                    .add(::core::mem::size_of::<*const u8>())
                                    .cast::<i32>();
                                let l6 = *ptr2
                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                    .cast::<*mut u8>();
                                let l7 = *ptr2
                                    .add(3 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>();
                                let len8 = l7;
                                let bytes8 = _rt::Vec::from_raw_parts(
                                    l6.cast(),
                                    len8,
                                    len8,
                                );
                                let l9 = i32::from(
                                    *ptr2
                                        .add(4 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>(),
                                );
                                super::super::super::reinhardt::dentdelion::types::PluginError {
                                    code: l5 as u32,
                                    message: _rt::string_lift(bytes8),
                                    details: match l9 {
                                        0 => None,
                                        1 => {
                                            let e = {
                                                let l10 = *ptr2
                                                    .add(5 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>();
                                                let l11 = *ptr2
                                                    .add(6 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len12 = l11;
                                                let bytes12 = _rt::Vec::from_raw_parts(
                                                    l10.cast(),
                                                    len12,
                                                    len12,
                                                );
                                                _rt::string_lift(bytes12)
                                            };
                                            Some(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                    },
                                }
                            };
                            Err(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                    };
                    result13
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// ===== Logging =====
            /// Log a debug message.
            pub fn log_debug(message: &str) -> () {
                unsafe {
                    let vec0 = message;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "reinhardt:dentdelion/host@0.1.0")]
                    unsafe extern "C" {
                        #[link_name = "log-debug"]
                        fn wit_import1(_: *mut u8, _: usize);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import1(_: *mut u8, _: usize) {
                        unreachable!()
                    }
                    unsafe { wit_import1(ptr0.cast_mut(), len0) };
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Log an info message.
            pub fn log_info(message: &str) -> () {
                unsafe {
                    let vec0 = message;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "reinhardt:dentdelion/host@0.1.0")]
                    unsafe extern "C" {
                        #[link_name = "log-info"]
                        fn wit_import1(_: *mut u8, _: usize);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import1(_: *mut u8, _: usize) {
                        unreachable!()
                    }
                    unsafe { wit_import1(ptr0.cast_mut(), len0) };
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Log a warning message.
            pub fn log_warn(message: &str) -> () {
                unsafe {
                    let vec0 = message;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "reinhardt:dentdelion/host@0.1.0")]
                    unsafe extern "C" {
                        #[link_name = "log-warn"]
                        fn wit_import1(_: *mut u8, _: usize);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import1(_: *mut u8, _: usize) {
                        unreachable!()
                    }
                    unsafe { wit_import1(ptr0.cast_mut(), len0) };
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Log an error message.
            pub fn log_error(message: &str) -> () {
                unsafe {
                    let vec0 = message;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "reinhardt:dentdelion/host@0.1.0")]
                    unsafe extern "C" {
                        #[link_name = "log-error"]
                        fn wit_import1(_: *mut u8, _: usize);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import1(_: *mut u8, _: usize) {
                        unreachable!()
                    }
                    unsafe { wit_import1(ptr0.cast_mut(), len0) };
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// ===== Service Registration =====
            /// Register a service with the DI container.
            /// Data is MessagePack-serialized service state.
            pub fn register_service(name: &str, data: &[u8]) -> Result<(), PluginError> {
                unsafe {
                    #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                    #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 7 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 7
                            * ::core::mem::size_of::<*const u8>()],
                    );
                    let vec0 = name;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    let vec1 = data;
                    let ptr1 = vec1.as_ptr().cast::<u8>();
                    let len1 = vec1.len();
                    let ptr2 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "reinhardt:dentdelion/host@0.1.0")]
                    unsafe extern "C" {
                        #[link_name = "register-service"]
                        fn wit_import3(
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        );
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import3(
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                    ) {
                        unreachable!()
                    }
                    unsafe {
                        wit_import3(ptr0.cast_mut(), len0, ptr1.cast_mut(), len1, ptr2)
                    };
                    let l4 = i32::from(*ptr2.add(0).cast::<u8>());
                    let result13 = match l4 {
                        0 => {
                            let e = ();
                            Ok(e)
                        }
                        1 => {
                            let e = {
                                let l5 = *ptr2
                                    .add(::core::mem::size_of::<*const u8>())
                                    .cast::<i32>();
                                let l6 = *ptr2
                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                    .cast::<*mut u8>();
                                let l7 = *ptr2
                                    .add(3 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>();
                                let len8 = l7;
                                let bytes8 = _rt::Vec::from_raw_parts(
                                    l6.cast(),
                                    len8,
                                    len8,
                                );
                                let l9 = i32::from(
                                    *ptr2
                                        .add(4 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>(),
                                );
                                super::super::super::reinhardt::dentdelion::types::PluginError {
                                    code: l5 as u32,
                                    message: _rt::string_lift(bytes8),
                                    details: match l9 {
                                        0 => None,
                                        1 => {
                                            let e = {
                                                let l10 = *ptr2
                                                    .add(5 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>();
                                                let l11 = *ptr2
                                                    .add(6 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len12 = l11;
                                                let bytes12 = _rt::Vec::from_raw_parts(
                                                    l10.cast(),
                                                    len12,
                                                    len12,
                                                );
                                                _rt::string_lift(bytes12)
                                            };
                                            Some(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                    },
                                }
                            };
                            Err(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                    };
                    result13
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Get a registered service by name.
            /// Returns MessagePack-serialized service state.
            pub fn get_service(name: &str) -> Option<_rt::Vec<u8>> {
                unsafe {
                    #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                    #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 3 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 3
                            * ::core::mem::size_of::<*const u8>()],
                    );
                    let vec0 = name;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "reinhardt:dentdelion/host@0.1.0")]
                    unsafe extern "C" {
                        #[link_name = "get-service"]
                        fn wit_import2(_: *mut u8, _: usize, _: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import2(_: *mut u8, _: usize, _: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import2(ptr0.cast_mut(), len0, ptr1) };
                    let l3 = i32::from(*ptr1.add(0).cast::<u8>());
                    let result7 = match l3 {
                        0 => None,
                        1 => {
                            let e = {
                                let l4 = *ptr1
                                    .add(::core::mem::size_of::<*const u8>())
                                    .cast::<*mut u8>();
                                let l5 = *ptr1
                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>();
                                let len6 = l5;
                                _rt::Vec::from_raw_parts(l4.cast(), len6, len6)
                            };
                            Some(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                    };
                    result7
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Unregister a service from the DI container.
            pub fn unregister_service(name: &str) -> Result<(), PluginError> {
                unsafe {
                    #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                    #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 7 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 7
                            * ::core::mem::size_of::<*const u8>()],
                    );
                    let vec0 = name;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "reinhardt:dentdelion/host@0.1.0")]
                    unsafe extern "C" {
                        #[link_name = "unregister-service"]
                        fn wit_import2(_: *mut u8, _: usize, _: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import2(_: *mut u8, _: usize, _: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import2(ptr0.cast_mut(), len0, ptr1) };
                    let l3 = i32::from(*ptr1.add(0).cast::<u8>());
                    let result12 = match l3 {
                        0 => {
                            let e = ();
                            Ok(e)
                        }
                        1 => {
                            let e = {
                                let l4 = *ptr1
                                    .add(::core::mem::size_of::<*const u8>())
                                    .cast::<i32>();
                                let l5 = *ptr1
                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                    .cast::<*mut u8>();
                                let l6 = *ptr1
                                    .add(3 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>();
                                let len7 = l6;
                                let bytes7 = _rt::Vec::from_raw_parts(
                                    l5.cast(),
                                    len7,
                                    len7,
                                );
                                let l8 = i32::from(
                                    *ptr1
                                        .add(4 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>(),
                                );
                                super::super::super::reinhardt::dentdelion::types::PluginError {
                                    code: l4 as u32,
                                    message: _rt::string_lift(bytes7),
                                    details: match l8 {
                                        0 => None,
                                        1 => {
                                            let e = {
                                                let l9 = *ptr1
                                                    .add(5 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>();
                                                let l10 = *ptr1
                                                    .add(6 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len11 = l10;
                                                let bytes11 = _rt::Vec::from_raw_parts(
                                                    l9.cast(),
                                                    len11,
                                                    len11,
                                                );
                                                _rt::string_lift(bytes11)
                                            };
                                            Some(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                    },
                                }
                            };
                            Err(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                    };
                    result12
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// ===== HTTP Client (requires capability check) =====
            /// Perform an HTTP GET request.
            /// Requires: Plugin must have appropriate network capability.
            pub fn http_get(
                url: &str,
                headers: &[(_rt::String, _rt::String)],
            ) -> Result<HttpResponse, PluginError> {
                unsafe {
                    #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                    #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 7 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 7
                            * ::core::mem::size_of::<*const u8>()],
                    );
                    let vec0 = url;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    let vec4 = headers;
                    let len4 = vec4.len();
                    let layout4 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec4.len() * (4 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let result4 = if layout4.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout4).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout4);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec4.into_iter().enumerate() {
                        let base = result4
                            .add(i * (4 * ::core::mem::size_of::<*const u8>()));
                        {
                            let (t1_0, t1_1) = e;
                            let vec2 = t1_0;
                            let ptr2 = vec2.as_ptr().cast::<u8>();
                            let len2 = vec2.len();
                            *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len2;
                            *base.add(0).cast::<*mut u8>() = ptr2.cast_mut();
                            let vec3 = t1_1;
                            let ptr3 = vec3.as_ptr().cast::<u8>();
                            let len3 = vec3.len();
                            *base
                                .add(3 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len3;
                            *base
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr3.cast_mut();
                        }
                    }
                    let ptr5 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "reinhardt:dentdelion/host@0.1.0")]
                    unsafe extern "C" {
                        #[link_name = "http-get"]
                        fn wit_import6(
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        );
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import6(
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                    ) {
                        unreachable!()
                    }
                    unsafe { wit_import6(ptr0.cast_mut(), len0, result4, len4, ptr5) };
                    let l7 = i32::from(*ptr5.add(0).cast::<u8>());
                    let result29 = match l7 {
                        0 => {
                            let e = {
                                let l8 = i32::from(
                                    *ptr5.add(::core::mem::size_of::<*const u8>()).cast::<u16>(),
                                );
                                let l9 = *ptr5
                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                    .cast::<*mut u8>();
                                let l10 = *ptr5
                                    .add(3 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>();
                                let base17 = l9;
                                let len17 = l10;
                                let mut result17 = _rt::Vec::with_capacity(len17);
                                for i in 0..len17 {
                                    let base = base17
                                        .add(i * (4 * ::core::mem::size_of::<*const u8>()));
                                    let e17 = {
                                        let l11 = *base.add(0).cast::<*mut u8>();
                                        let l12 = *base
                                            .add(::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len13 = l12;
                                        let bytes13 = _rt::Vec::from_raw_parts(
                                            l11.cast(),
                                            len13,
                                            len13,
                                        );
                                        let l14 = *base
                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>();
                                        let l15 = *base
                                            .add(3 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len16 = l15;
                                        let bytes16 = _rt::Vec::from_raw_parts(
                                            l14.cast(),
                                            len16,
                                            len16,
                                        );
                                        (_rt::string_lift(bytes13), _rt::string_lift(bytes16))
                                    };
                                    result17.push(e17);
                                }
                                _rt::cabi_dealloc(
                                    base17,
                                    len17 * (4 * ::core::mem::size_of::<*const u8>()),
                                    ::core::mem::size_of::<*const u8>(),
                                );
                                let l18 = *ptr5
                                    .add(4 * ::core::mem::size_of::<*const u8>())
                                    .cast::<*mut u8>();
                                let l19 = *ptr5
                                    .add(5 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>();
                                let len20 = l19;
                                super::super::super::reinhardt::dentdelion::types::HttpResponse {
                                    status: l8 as u16,
                                    headers: result17,
                                    body: _rt::Vec::from_raw_parts(l18.cast(), len20, len20),
                                }
                            };
                            Ok(e)
                        }
                        1 => {
                            let e = {
                                let l21 = *ptr5
                                    .add(::core::mem::size_of::<*const u8>())
                                    .cast::<i32>();
                                let l22 = *ptr5
                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                    .cast::<*mut u8>();
                                let l23 = *ptr5
                                    .add(3 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>();
                                let len24 = l23;
                                let bytes24 = _rt::Vec::from_raw_parts(
                                    l22.cast(),
                                    len24,
                                    len24,
                                );
                                let l25 = i32::from(
                                    *ptr5
                                        .add(4 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>(),
                                );
                                super::super::super::reinhardt::dentdelion::types::PluginError {
                                    code: l21 as u32,
                                    message: _rt::string_lift(bytes24),
                                    details: match l25 {
                                        0 => None,
                                        1 => {
                                            let e = {
                                                let l26 = *ptr5
                                                    .add(5 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>();
                                                let l27 = *ptr5
                                                    .add(6 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len28 = l27;
                                                let bytes28 = _rt::Vec::from_raw_parts(
                                                    l26.cast(),
                                                    len28,
                                                    len28,
                                                );
                                                _rt::string_lift(bytes28)
                                            };
                                            Some(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                    },
                                }
                            };
                            Err(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                    };
                    if layout4.size() != 0 {
                        _rt::alloc::dealloc(result4.cast(), layout4);
                    }
                    result29
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Perform an HTTP POST request.
            /// Requires: Plugin must have appropriate network capability.
            pub fn http_post(
                url: &str,
                body: &[u8],
                headers: &[(_rt::String, _rt::String)],
            ) -> Result<HttpResponse, PluginError> {
                unsafe {
                    #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                    #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 7 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 7
                            * ::core::mem::size_of::<*const u8>()],
                    );
                    let vec0 = url;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    let vec1 = body;
                    let ptr1 = vec1.as_ptr().cast::<u8>();
                    let len1 = vec1.len();
                    let vec5 = headers;
                    let len5 = vec5.len();
                    let layout5 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec5.len() * (4 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let result5 = if layout5.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout5).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout5);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec5.into_iter().enumerate() {
                        let base = result5
                            .add(i * (4 * ::core::mem::size_of::<*const u8>()));
                        {
                            let (t2_0, t2_1) = e;
                            let vec3 = t2_0;
                            let ptr3 = vec3.as_ptr().cast::<u8>();
                            let len3 = vec3.len();
                            *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len3;
                            *base.add(0).cast::<*mut u8>() = ptr3.cast_mut();
                            let vec4 = t2_1;
                            let ptr4 = vec4.as_ptr().cast::<u8>();
                            let len4 = vec4.len();
                            *base
                                .add(3 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len4;
                            *base
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr4.cast_mut();
                        }
                    }
                    let ptr6 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "reinhardt:dentdelion/host@0.1.0")]
                    unsafe extern "C" {
                        #[link_name = "http-post"]
                        fn wit_import7(
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        );
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import7(
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                    ) {
                        unreachable!()
                    }
                    unsafe {
                        wit_import7(
                            ptr0.cast_mut(),
                            len0,
                            ptr1.cast_mut(),
                            len1,
                            result5,
                            len5,
                            ptr6,
                        )
                    };
                    let l8 = i32::from(*ptr6.add(0).cast::<u8>());
                    let result30 = match l8 {
                        0 => {
                            let e = {
                                let l9 = i32::from(
                                    *ptr6.add(::core::mem::size_of::<*const u8>()).cast::<u16>(),
                                );
                                let l10 = *ptr6
                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                    .cast::<*mut u8>();
                                let l11 = *ptr6
                                    .add(3 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>();
                                let base18 = l10;
                                let len18 = l11;
                                let mut result18 = _rt::Vec::with_capacity(len18);
                                for i in 0..len18 {
                                    let base = base18
                                        .add(i * (4 * ::core::mem::size_of::<*const u8>()));
                                    let e18 = {
                                        let l12 = *base.add(0).cast::<*mut u8>();
                                        let l13 = *base
                                            .add(::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len14 = l13;
                                        let bytes14 = _rt::Vec::from_raw_parts(
                                            l12.cast(),
                                            len14,
                                            len14,
                                        );
                                        let l15 = *base
                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>();
                                        let l16 = *base
                                            .add(3 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len17 = l16;
                                        let bytes17 = _rt::Vec::from_raw_parts(
                                            l15.cast(),
                                            len17,
                                            len17,
                                        );
                                        (_rt::string_lift(bytes14), _rt::string_lift(bytes17))
                                    };
                                    result18.push(e18);
                                }
                                _rt::cabi_dealloc(
                                    base18,
                                    len18 * (4 * ::core::mem::size_of::<*const u8>()),
                                    ::core::mem::size_of::<*const u8>(),
                                );
                                let l19 = *ptr6
                                    .add(4 * ::core::mem::size_of::<*const u8>())
                                    .cast::<*mut u8>();
                                let l20 = *ptr6
                                    .add(5 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>();
                                let len21 = l20;
                                super::super::super::reinhardt::dentdelion::types::HttpResponse {
                                    status: l9 as u16,
                                    headers: result18,
                                    body: _rt::Vec::from_raw_parts(l19.cast(), len21, len21),
                                }
                            };
                            Ok(e)
                        }
                        1 => {
                            let e = {
                                let l22 = *ptr6
                                    .add(::core::mem::size_of::<*const u8>())
                                    .cast::<i32>();
                                let l23 = *ptr6
                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                    .cast::<*mut u8>();
                                let l24 = *ptr6
                                    .add(3 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>();
                                let len25 = l24;
                                let bytes25 = _rt::Vec::from_raw_parts(
                                    l23.cast(),
                                    len25,
                                    len25,
                                );
                                let l26 = i32::from(
                                    *ptr6
                                        .add(4 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>(),
                                );
                                super::super::super::reinhardt::dentdelion::types::PluginError {
                                    code: l22 as u32,
                                    message: _rt::string_lift(bytes25),
                                    details: match l26 {
                                        0 => None,
                                        1 => {
                                            let e = {
                                                let l27 = *ptr6
                                                    .add(5 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>();
                                                let l28 = *ptr6
                                                    .add(6 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len29 = l28;
                                                let bytes29 = _rt::Vec::from_raw_parts(
                                                    l27.cast(),
                                                    len29,
                                                    len29,
                                                );
                                                _rt::string_lift(bytes29)
                                            };
                                            Some(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                    },
                                }
                            };
                            Err(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                    };
                    if layout5.size() != 0 {
                        _rt::alloc::dealloc(result5.cast(), layout5);
                    }
                    result30
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// ===== Database Access (requires capability check) =====
            /// Execute a SQL query and return results.
            /// Params is MessagePack-serialized query parameters.
            /// Returns MessagePack-serialized result rows.
            /// Requires: Plugin must have database capability.
            pub fn db_query(
                sql: &str,
                params: &[u8],
            ) -> Result<_rt::Vec<u8>, PluginError> {
                unsafe {
                    #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                    #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 7 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 7
                            * ::core::mem::size_of::<*const u8>()],
                    );
                    let vec0 = sql;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    let vec1 = params;
                    let ptr1 = vec1.as_ptr().cast::<u8>();
                    let len1 = vec1.len();
                    let ptr2 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "reinhardt:dentdelion/host@0.1.0")]
                    unsafe extern "C" {
                        #[link_name = "db-query"]
                        fn wit_import3(
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        );
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import3(
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                    ) {
                        unreachable!()
                    }
                    unsafe {
                        wit_import3(ptr0.cast_mut(), len0, ptr1.cast_mut(), len1, ptr2)
                    };
                    let l4 = i32::from(*ptr2.add(0).cast::<u8>());
                    let result16 = match l4 {
                        0 => {
                            let e = {
                                let l5 = *ptr2
                                    .add(::core::mem::size_of::<*const u8>())
                                    .cast::<*mut u8>();
                                let l6 = *ptr2
                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>();
                                let len7 = l6;
                                _rt::Vec::from_raw_parts(l5.cast(), len7, len7)
                            };
                            Ok(e)
                        }
                        1 => {
                            let e = {
                                let l8 = *ptr2
                                    .add(::core::mem::size_of::<*const u8>())
                                    .cast::<i32>();
                                let l9 = *ptr2
                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                    .cast::<*mut u8>();
                                let l10 = *ptr2
                                    .add(3 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>();
                                let len11 = l10;
                                let bytes11 = _rt::Vec::from_raw_parts(
                                    l9.cast(),
                                    len11,
                                    len11,
                                );
                                let l12 = i32::from(
                                    *ptr2
                                        .add(4 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>(),
                                );
                                super::super::super::reinhardt::dentdelion::types::PluginError {
                                    code: l8 as u32,
                                    message: _rt::string_lift(bytes11),
                                    details: match l12 {
                                        0 => None,
                                        1 => {
                                            let e = {
                                                let l13 = *ptr2
                                                    .add(5 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>();
                                                let l14 = *ptr2
                                                    .add(6 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len15 = l14;
                                                let bytes15 = _rt::Vec::from_raw_parts(
                                                    l13.cast(),
                                                    len15,
                                                    len15,
                                                );
                                                _rt::string_lift(bytes15)
                                            };
                                            Some(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                    },
                                }
                            };
                            Err(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                    };
                    result16
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Execute a SQL statement (INSERT, UPDATE, DELETE).
            /// Returns number of affected rows.
            /// Requires: Plugin must have database capability.
            pub fn db_execute(sql: &str, params: &[u8]) -> Result<u64, PluginError> {
                unsafe {
                    #[repr(align(8))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 8 + 6 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 8
                            + 6 * ::core::mem::size_of::<*const u8>()],
                    );
                    let vec0 = sql;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    let vec1 = params;
                    let ptr1 = vec1.as_ptr().cast::<u8>();
                    let len1 = vec1.len();
                    let ptr2 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "reinhardt:dentdelion/host@0.1.0")]
                    unsafe extern "C" {
                        #[link_name = "db-execute"]
                        fn wit_import3(
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        );
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import3(
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                    ) {
                        unreachable!()
                    }
                    unsafe {
                        wit_import3(ptr0.cast_mut(), len0, ptr1.cast_mut(), len1, ptr2)
                    };
                    let l4 = i32::from(*ptr2.add(0).cast::<u8>());
                    let result14 = match l4 {
                        0 => {
                            let e = {
                                let l5 = *ptr2.add(8).cast::<i64>();
                                l5 as u64
                            };
                            Ok(e)
                        }
                        1 => {
                            let e = {
                                let l6 = *ptr2.add(8).cast::<i32>();
                                let l7 = *ptr2
                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                    .cast::<*mut u8>();
                                let l8 = *ptr2
                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>();
                                let len9 = l8;
                                let bytes9 = _rt::Vec::from_raw_parts(
                                    l7.cast(),
                                    len9,
                                    len9,
                                );
                                let l10 = i32::from(
                                    *ptr2
                                        .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>(),
                                );
                                super::super::super::reinhardt::dentdelion::types::PluginError {
                                    code: l6 as u32,
                                    message: _rt::string_lift(bytes9),
                                    details: match l10 {
                                        0 => None,
                                        1 => {
                                            let e = {
                                                let l11 = *ptr2
                                                    .add(8 + 4 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>();
                                                let l12 = *ptr2
                                                    .add(8 + 5 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len13 = l12;
                                                let bytes13 = _rt::Vec::from_raw_parts(
                                                    l11.cast(),
                                                    len13,
                                                    len13,
                                                );
                                                _rt::string_lift(bytes13)
                                            };
                                            Some(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                    },
                                }
                            };
                            Err(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                    };
                    result14
                }
            }
        }
    }
}
#[rustfmt::skip]
#[allow(dead_code, clippy::all)]
pub mod exports {
    pub mod reinhardt {
        pub mod dentdelion {
            /// Plugin API - Functions that plugins must export.
            ///
            /// These functions are called by the host to manage the plugin lifecycle
            /// and query plugin information.
            #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
            pub mod plugin {
                #[used]
                #[doc(hidden)]
                static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type PluginMetadata = super::super::super::super::reinhardt::dentdelion::types::PluginMetadata;
                pub type Capability = super::super::super::super::reinhardt::dentdelion::types::Capability;
                pub type PluginError = super::super::super::super::reinhardt::dentdelion::types::PluginError;
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_get_metadata_cabi<T: Guest>() -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::get_metadata();
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let super::super::super::super::reinhardt::dentdelion::types::PluginMetadata {
                        name: name2,
                        version: version2,
                        description: description2,
                        authors: authors2,
                        license: license2,
                        repository: repository2,
                        homepage: homepage2,
                    } = result0;
                    let vec3 = (name2.into_bytes()).into_boxed_slice();
                    let ptr3 = vec3.as_ptr().cast::<u8>();
                    let len3 = vec3.len();
                    ::core::mem::forget(vec3);
                    *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len3;
                    *ptr1.add(0).cast::<*mut u8>() = ptr3.cast_mut();
                    let vec4 = (version2.into_bytes()).into_boxed_slice();
                    let ptr4 = vec4.as_ptr().cast::<u8>();
                    let len4 = vec4.len();
                    ::core::mem::forget(vec4);
                    *ptr1.add(3 * ::core::mem::size_of::<*const u8>()).cast::<usize>() = len4;
                    *ptr1
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>() = ptr4.cast_mut();
                    match description2 {
                        Some(e) => {
                            *ptr1
                                .add(4 * ::core::mem::size_of::<*const u8>())
                                .cast::<u8>() = (1i32) as u8;
                            let vec5 = (e.into_bytes()).into_boxed_slice();
                            let ptr5 = vec5.as_ptr().cast::<u8>();
                            let len5 = vec5.len();
                            ::core::mem::forget(vec5);
                            *ptr1
                                .add(6 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len5;
                            *ptr1
                                .add(5 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr5.cast_mut();
                        }
                        None => {
                            *ptr1
                                .add(4 * ::core::mem::size_of::<*const u8>())
                                .cast::<u8>() = (0i32) as u8;
                        }
                    };
                    let vec7 = authors2;
                    let len7 = vec7.len();
                    let layout7 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec7.len() * (2 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let result7 = if layout7.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout7).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout7);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec7.into_iter().enumerate() {
                        let base = result7
                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                        {
                            let vec6 = (e.into_bytes()).into_boxed_slice();
                            let ptr6 = vec6.as_ptr().cast::<u8>();
                            let len6 = vec6.len();
                            ::core::mem::forget(vec6);
                            *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len6;
                            *base.add(0).cast::<*mut u8>() = ptr6.cast_mut();
                        }
                    }
                    *ptr1.add(8 * ::core::mem::size_of::<*const u8>()).cast::<usize>() = len7;
                    *ptr1
                        .add(7 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>() = result7;
                    match license2 {
                        Some(e) => {
                            *ptr1
                                .add(9 * ::core::mem::size_of::<*const u8>())
                                .cast::<u8>() = (1i32) as u8;
                            let vec8 = (e.into_bytes()).into_boxed_slice();
                            let ptr8 = vec8.as_ptr().cast::<u8>();
                            let len8 = vec8.len();
                            ::core::mem::forget(vec8);
                            *ptr1
                                .add(11 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len8;
                            *ptr1
                                .add(10 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr8.cast_mut();
                        }
                        None => {
                            *ptr1
                                .add(9 * ::core::mem::size_of::<*const u8>())
                                .cast::<u8>() = (0i32) as u8;
                        }
                    };
                    match repository2 {
                        Some(e) => {
                            *ptr1
                                .add(12 * ::core::mem::size_of::<*const u8>())
                                .cast::<u8>() = (1i32) as u8;
                            let vec9 = (e.into_bytes()).into_boxed_slice();
                            let ptr9 = vec9.as_ptr().cast::<u8>();
                            let len9 = vec9.len();
                            ::core::mem::forget(vec9);
                            *ptr1
                                .add(14 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len9;
                            *ptr1
                                .add(13 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr9.cast_mut();
                        }
                        None => {
                            *ptr1
                                .add(12 * ::core::mem::size_of::<*const u8>())
                                .cast::<u8>() = (0i32) as u8;
                        }
                    };
                    match homepage2 {
                        Some(e) => {
                            *ptr1
                                .add(15 * ::core::mem::size_of::<*const u8>())
                                .cast::<u8>() = (1i32) as u8;
                            let vec10 = (e.into_bytes()).into_boxed_slice();
                            let ptr10 = vec10.as_ptr().cast::<u8>();
                            let len10 = vec10.len();
                            ::core::mem::forget(vec10);
                            *ptr1
                                .add(17 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len10;
                            *ptr1
                                .add(16 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr10.cast_mut();
                        }
                        None => {
                            *ptr1
                                .add(15 * ::core::mem::size_of::<*const u8>())
                                .cast::<u8>() = (0i32) as u8;
                        }
                    };
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_get_metadata<T: Guest>(arg0: *mut u8) {
                    let l0 = *arg0.add(0).cast::<*mut u8>();
                    let l1 = *arg0
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l0, l1, 1);
                    let l2 = *arg0
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l3 = *arg0
                        .add(3 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l2, l3, 1);
                    let l4 = i32::from(
                        *arg0.add(4 * ::core::mem::size_of::<*const u8>()).cast::<u8>(),
                    );
                    match l4 {
                        0 => {}
                        _ => {
                            let l5 = *arg0
                                .add(5 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l6 = *arg0
                                .add(6 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l5, l6, 1);
                        }
                    }
                    let l7 = *arg0
                        .add(7 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l8 = *arg0
                        .add(8 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let base11 = l7;
                    let len11 = l8;
                    for i in 0..len11 {
                        let base = base11
                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                        {
                            let l9 = *base.add(0).cast::<*mut u8>();
                            let l10 = *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l9, l10, 1);
                        }
                    }
                    _rt::cabi_dealloc(
                        base11,
                        len11 * (2 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let l12 = i32::from(
                        *arg0.add(9 * ::core::mem::size_of::<*const u8>()).cast::<u8>(),
                    );
                    match l12 {
                        0 => {}
                        _ => {
                            let l13 = *arg0
                                .add(10 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l14 = *arg0
                                .add(11 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l13, l14, 1);
                        }
                    }
                    let l15 = i32::from(
                        *arg0.add(12 * ::core::mem::size_of::<*const u8>()).cast::<u8>(),
                    );
                    match l15 {
                        0 => {}
                        _ => {
                            let l16 = *arg0
                                .add(13 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l17 = *arg0
                                .add(14 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l16, l17, 1);
                        }
                    }
                    let l18 = i32::from(
                        *arg0.add(15 * ::core::mem::size_of::<*const u8>()).cast::<u8>(),
                    );
                    match l18 {
                        0 => {}
                        _ => {
                            let l19 = *arg0
                                .add(16 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l20 = *arg0
                                .add(17 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l19, l20, 1);
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_get_capabilities_cabi<T: Guest>() -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::get_capabilities();
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let vec4 = result0;
                    let len4 = vec4.len();
                    let layout4 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec4.len() * (3 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let result4 = if layout4.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout4).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout4);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec4.into_iter().enumerate() {
                        let base = result4
                            .add(i * (3 * ::core::mem::size_of::<*const u8>()));
                        {
                            use super::super::super::super::reinhardt::dentdelion::types::Capability as V3;
                            match e {
                                V3::Middleware => {
                                    *base.add(0).cast::<u8>() = (0i32) as u8;
                                }
                                V3::Commands => {
                                    *base.add(0).cast::<u8>() = (1i32) as u8;
                                }
                                V3::ViewSets => {
                                    *base.add(0).cast::<u8>() = (2i32) as u8;
                                }
                                V3::Signals => {
                                    *base.add(0).cast::<u8>() = (3i32) as u8;
                                }
                                V3::Services => {
                                    *base.add(0).cast::<u8>() = (4i32) as u8;
                                }
                                V3::Auth => {
                                    *base.add(0).cast::<u8>() = (5i32) as u8;
                                }
                                V3::Templates => {
                                    *base.add(0).cast::<u8>() = (6i32) as u8;
                                }
                                V3::StaticFiles => {
                                    *base.add(0).cast::<u8>() = (7i32) as u8;
                                }
                                V3::Routing => {
                                    *base.add(0).cast::<u8>() = (8i32) as u8;
                                }
                                V3::SignalReceivers => {
                                    *base.add(0).cast::<u8>() = (9i32) as u8;
                                }
                                V3::Handlers => {
                                    *base.add(0).cast::<u8>() = (10i32) as u8;
                                }
                                V3::NetworkAccess => {
                                    *base.add(0).cast::<u8>() = (11i32) as u8;
                                }
                                V3::DatabaseAccess => {
                                    *base.add(0).cast::<u8>() = (12i32) as u8;
                                }
                                V3::Custom(e) => {
                                    *base.add(0).cast::<u8>() = (13i32) as u8;
                                    let vec2 = (e.into_bytes()).into_boxed_slice();
                                    let ptr2 = vec2.as_ptr().cast::<u8>();
                                    let len2 = vec2.len();
                                    ::core::mem::forget(vec2);
                                    *base
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len2;
                                    *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr2.cast_mut();
                                }
                            }
                        }
                    }
                    *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len4;
                    *ptr1.add(0).cast::<*mut u8>() = result4;
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_get_capabilities<T: Guest>(arg0: *mut u8) {
                    let l0 = *arg0.add(0).cast::<*mut u8>();
                    let l1 = *arg0
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let base5 = l0;
                    let len5 = l1;
                    for i in 0..len5 {
                        let base = base5
                            .add(i * (3 * ::core::mem::size_of::<*const u8>()));
                        {
                            let l2 = i32::from(*base.add(0).cast::<u8>());
                            match l2 {
                                0 => {}
                                1 => {}
                                2 => {}
                                3 => {}
                                4 => {}
                                5 => {}
                                6 => {}
                                7 => {}
                                8 => {}
                                9 => {}
                                10 => {}
                                11 => {}
                                12 => {}
                                _ => {
                                    let l3 = *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l4 = *base
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l3, l4, 1);
                                }
                            }
                        }
                    }
                    _rt::cabi_dealloc(
                        base5,
                        len5 * (3 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_on_load_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg1;
                    let result1 = T::on_load(
                        _rt::Vec::from_raw_parts(arg0.cast(), len0, len0),
                    );
                    let ptr2 = (&raw mut _RET_AREA.0).cast::<u8>();
                    match result1 {
                        Ok(_) => {
                            *ptr2.add(0).cast::<u8>() = (0i32) as u8;
                        }
                        Err(e) => {
                            *ptr2.add(0).cast::<u8>() = (1i32) as u8;
                            let super::super::super::super::reinhardt::dentdelion::types::PluginError {
                                code: code3,
                                message: message3,
                                details: details3,
                            } = e;
                            *ptr2
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<i32>() = _rt::as_i32(code3);
                            let vec4 = (message3.into_bytes()).into_boxed_slice();
                            let ptr4 = vec4.as_ptr().cast::<u8>();
                            let len4 = vec4.len();
                            ::core::mem::forget(vec4);
                            *ptr2
                                .add(3 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len4;
                            *ptr2
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr4.cast_mut();
                            match details3 {
                                Some(e) => {
                                    *ptr2
                                        .add(4 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (1i32) as u8;
                                    let vec5 = (e.into_bytes()).into_boxed_slice();
                                    let ptr5 = vec5.as_ptr().cast::<u8>();
                                    let len5 = vec5.len();
                                    ::core::mem::forget(vec5);
                                    *ptr2
                                        .add(6 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len5;
                                    *ptr2
                                        .add(5 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr5.cast_mut();
                                }
                                None => {
                                    *ptr2
                                        .add(4 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (0i32) as u8;
                                }
                            };
                        }
                    };
                    ptr2
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_on_load<T: Guest>(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {}
                        _ => {
                            let l1 = *arg0
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l2 = *arg0
                                .add(3 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l1, l2, 1);
                            let l3 = i32::from(
                                *arg0
                                    .add(4 * ::core::mem::size_of::<*const u8>())
                                    .cast::<u8>(),
                            );
                            match l3 {
                                0 => {}
                                _ => {
                                    let l4 = *arg0
                                        .add(5 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l5 = *arg0
                                        .add(6 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l4, l5, 1);
                                }
                            }
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_on_enable_cabi<T: Guest>() -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::on_enable();
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    match result0 {
                        Ok(_) => {
                            *ptr1.add(0).cast::<u8>() = (0i32) as u8;
                        }
                        Err(e) => {
                            *ptr1.add(0).cast::<u8>() = (1i32) as u8;
                            let super::super::super::super::reinhardt::dentdelion::types::PluginError {
                                code: code2,
                                message: message2,
                                details: details2,
                            } = e;
                            *ptr1
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<i32>() = _rt::as_i32(code2);
                            let vec3 = (message2.into_bytes()).into_boxed_slice();
                            let ptr3 = vec3.as_ptr().cast::<u8>();
                            let len3 = vec3.len();
                            ::core::mem::forget(vec3);
                            *ptr1
                                .add(3 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len3;
                            *ptr1
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr3.cast_mut();
                            match details2 {
                                Some(e) => {
                                    *ptr1
                                        .add(4 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (1i32) as u8;
                                    let vec4 = (e.into_bytes()).into_boxed_slice();
                                    let ptr4 = vec4.as_ptr().cast::<u8>();
                                    let len4 = vec4.len();
                                    ::core::mem::forget(vec4);
                                    *ptr1
                                        .add(6 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len4;
                                    *ptr1
                                        .add(5 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr4.cast_mut();
                                }
                                None => {
                                    *ptr1
                                        .add(4 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (0i32) as u8;
                                }
                            };
                        }
                    };
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_on_enable<T: Guest>(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {}
                        _ => {
                            let l1 = *arg0
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l2 = *arg0
                                .add(3 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l1, l2, 1);
                            let l3 = i32::from(
                                *arg0
                                    .add(4 * ::core::mem::size_of::<*const u8>())
                                    .cast::<u8>(),
                            );
                            match l3 {
                                0 => {}
                                _ => {
                                    let l4 = *arg0
                                        .add(5 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l5 = *arg0
                                        .add(6 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l4, l5, 1);
                                }
                            }
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_on_disable_cabi<T: Guest>() -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::on_disable();
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    match result0 {
                        Ok(_) => {
                            *ptr1.add(0).cast::<u8>() = (0i32) as u8;
                        }
                        Err(e) => {
                            *ptr1.add(0).cast::<u8>() = (1i32) as u8;
                            let super::super::super::super::reinhardt::dentdelion::types::PluginError {
                                code: code2,
                                message: message2,
                                details: details2,
                            } = e;
                            *ptr1
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<i32>() = _rt::as_i32(code2);
                            let vec3 = (message2.into_bytes()).into_boxed_slice();
                            let ptr3 = vec3.as_ptr().cast::<u8>();
                            let len3 = vec3.len();
                            ::core::mem::forget(vec3);
                            *ptr1
                                .add(3 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len3;
                            *ptr1
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr3.cast_mut();
                            match details2 {
                                Some(e) => {
                                    *ptr1
                                        .add(4 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (1i32) as u8;
                                    let vec4 = (e.into_bytes()).into_boxed_slice();
                                    let ptr4 = vec4.as_ptr().cast::<u8>();
                                    let len4 = vec4.len();
                                    ::core::mem::forget(vec4);
                                    *ptr1
                                        .add(6 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len4;
                                    *ptr1
                                        .add(5 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr4.cast_mut();
                                }
                                None => {
                                    *ptr1
                                        .add(4 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (0i32) as u8;
                                }
                            };
                        }
                    };
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_on_disable<T: Guest>(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {}
                        _ => {
                            let l1 = *arg0
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l2 = *arg0
                                .add(3 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l1, l2, 1);
                            let l3 = i32::from(
                                *arg0
                                    .add(4 * ::core::mem::size_of::<*const u8>())
                                    .cast::<u8>(),
                            );
                            match l3 {
                                0 => {}
                                _ => {
                                    let l4 = *arg0
                                        .add(5 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l5 = *arg0
                                        .add(6 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l4, l5, 1);
                                }
                            }
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_on_unload_cabi<T: Guest>() -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::on_unload();
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    match result0 {
                        Ok(_) => {
                            *ptr1.add(0).cast::<u8>() = (0i32) as u8;
                        }
                        Err(e) => {
                            *ptr1.add(0).cast::<u8>() = (1i32) as u8;
                            let super::super::super::super::reinhardt::dentdelion::types::PluginError {
                                code: code2,
                                message: message2,
                                details: details2,
                            } = e;
                            *ptr1
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<i32>() = _rt::as_i32(code2);
                            let vec3 = (message2.into_bytes()).into_boxed_slice();
                            let ptr3 = vec3.as_ptr().cast::<u8>();
                            let len3 = vec3.len();
                            ::core::mem::forget(vec3);
                            *ptr1
                                .add(3 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len3;
                            *ptr1
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr3.cast_mut();
                            match details2 {
                                Some(e) => {
                                    *ptr1
                                        .add(4 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (1i32) as u8;
                                    let vec4 = (e.into_bytes()).into_boxed_slice();
                                    let ptr4 = vec4.as_ptr().cast::<u8>();
                                    let len4 = vec4.len();
                                    ::core::mem::forget(vec4);
                                    *ptr1
                                        .add(6 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len4;
                                    *ptr1
                                        .add(5 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr4.cast_mut();
                                }
                                None => {
                                    *ptr1
                                        .add(4 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (0i32) as u8;
                                }
                            };
                        }
                    };
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_on_unload<T: Guest>(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {}
                        _ => {
                            let l1 = *arg0
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l2 = *arg0
                                .add(3 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l1, l2, 1);
                            let l3 = i32::from(
                                *arg0
                                    .add(4 * ::core::mem::size_of::<*const u8>())
                                    .cast::<u8>(),
                            );
                            match l3 {
                                0 => {}
                                _ => {
                                    let l4 = *arg0
                                        .add(5 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l5 = *arg0
                                        .add(6 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l4, l5, 1);
                                }
                            }
                        }
                    }
                }
                pub trait Guest {
                    /// Get the plugin's metadata.
                    fn get_metadata() -> PluginMetadata;
                    /// Get the list of capabilities this plugin provides.
                    fn get_capabilities() -> _rt::Vec<Capability>;
                    /// Called when the plugin is loaded.
                    /// Config is MessagePack-serialized plugin configuration.
                    fn on_load(config: _rt::Vec<u8>) -> Result<(), PluginError>;
                    /// Called when the plugin is enabled.
                    fn on_enable() -> Result<(), PluginError>;
                    /// Called when the plugin is disabled.
                    fn on_disable() -> Result<(), PluginError>;
                    /// Called when the plugin is unloaded.
                    fn on_unload() -> Result<(), PluginError>;
                }
                #[doc(hidden)]
                macro_rules! __export_reinhardt_dentdelion_plugin_0_1_0_cabi {
                    ($ty:ident with_types_in $($path_to_types:tt)*) => {
                        const _ : () = { #[unsafe (export_name =
                        "reinhardt:dentdelion/plugin@0.1.0#get-metadata")] unsafe extern
                        "C" fn export_get_metadata() -> * mut u8 { unsafe {
                        $($path_to_types)*:: _export_get_metadata_cabi::<$ty > () } }
                        #[unsafe (export_name =
                        "cabi_post_reinhardt:dentdelion/plugin@0.1.0#get-metadata")]
                        unsafe extern "C" fn _post_return_get_metadata(arg0 : * mut u8,)
                        { unsafe { $($path_to_types)*:: __post_return_get_metadata::<$ty
                        > (arg0) } } #[unsafe (export_name =
                        "reinhardt:dentdelion/plugin@0.1.0#get-capabilities")] unsafe
                        extern "C" fn export_get_capabilities() -> * mut u8 { unsafe {
                        $($path_to_types)*:: _export_get_capabilities_cabi::<$ty > () } }
                        #[unsafe (export_name =
                        "cabi_post_reinhardt:dentdelion/plugin@0.1.0#get-capabilities")]
                        unsafe extern "C" fn _post_return_get_capabilities(arg0 : * mut
                        u8,) { unsafe { $($path_to_types)*::
                        __post_return_get_capabilities::<$ty > (arg0) } } #[unsafe
                        (export_name = "reinhardt:dentdelion/plugin@0.1.0#on-load")]
                        unsafe extern "C" fn export_on_load(arg0 : * mut u8, arg1 :
                        usize,) -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_on_load_cabi::<$ty > (arg0, arg1) } } #[unsafe
                        (export_name =
                        "cabi_post_reinhardt:dentdelion/plugin@0.1.0#on-load")] unsafe
                        extern "C" fn _post_return_on_load(arg0 : * mut u8,) { unsafe {
                        $($path_to_types)*:: __post_return_on_load::<$ty > (arg0) } }
                        #[unsafe (export_name =
                        "reinhardt:dentdelion/plugin@0.1.0#on-enable")] unsafe extern "C"
                        fn export_on_enable() -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_on_enable_cabi::<$ty > () } } #[unsafe (export_name =
                        "cabi_post_reinhardt:dentdelion/plugin@0.1.0#on-enable")] unsafe
                        extern "C" fn _post_return_on_enable(arg0 : * mut u8,) { unsafe {
                        $($path_to_types)*:: __post_return_on_enable::<$ty > (arg0) } }
                        #[unsafe (export_name =
                        "reinhardt:dentdelion/plugin@0.1.0#on-disable")] unsafe extern
                        "C" fn export_on_disable() -> * mut u8 { unsafe {
                        $($path_to_types)*:: _export_on_disable_cabi::<$ty > () } }
                        #[unsafe (export_name =
                        "cabi_post_reinhardt:dentdelion/plugin@0.1.0#on-disable")] unsafe
                        extern "C" fn _post_return_on_disable(arg0 : * mut u8,) { unsafe
                        { $($path_to_types)*:: __post_return_on_disable::<$ty > (arg0) }
                        } #[unsafe (export_name =
                        "reinhardt:dentdelion/plugin@0.1.0#on-unload")] unsafe extern "C"
                        fn export_on_unload() -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_on_unload_cabi::<$ty > () } } #[unsafe (export_name =
                        "cabi_post_reinhardt:dentdelion/plugin@0.1.0#on-unload")] unsafe
                        extern "C" fn _post_return_on_unload(arg0 : * mut u8,) { unsafe {
                        $($path_to_types)*:: __post_return_on_unload::<$ty > (arg0) } }
                        };
                    };
                }
                #[doc(hidden)]
                pub(crate) use __export_reinhardt_dentdelion_plugin_0_1_0_cabi;
                #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                struct _RetArea(
                    [::core::mem::MaybeUninit<
                        u8,
                    >; 18 * ::core::mem::size_of::<*const u8>()],
                );
                static mut _RET_AREA: _RetArea = _RetArea(
                    [::core::mem::MaybeUninit::uninit(); 18
                        * ::core::mem::size_of::<*const u8>()],
                );
            }
        }
    }
}
#[rustfmt::skip]
mod _rt {
    #![allow(dead_code, clippy::all)]
    pub use alloc_crate::string::String;
    pub use alloc_crate::vec::Vec;
    pub unsafe fn invalid_enum_discriminant<T>() -> T {
        if cfg!(debug_assertions) {
            panic!("invalid enum discriminant")
        } else {
            unsafe { core::hint::unreachable_unchecked() }
        }
    }
    pub unsafe fn string_lift(bytes: Vec<u8>) -> String {
        if cfg!(debug_assertions) {
            String::from_utf8(bytes).unwrap()
        } else {
            String::from_utf8_unchecked(bytes)
        }
    }
    pub use alloc_crate::alloc;
    pub unsafe fn cabi_dealloc(ptr: *mut u8, size: usize, align: usize) {
        if size == 0 {
            return;
        }
        let layout = alloc::Layout::from_size_align_unchecked(size, align);
        alloc::dealloc(ptr, layout);
    }
    #[cfg(target_arch = "wasm32")]
    pub fn run_ctors_once() {
        wit_bindgen_rt::run_ctors_once();
    }
    pub fn as_i32<T: AsI32>(t: T) -> i32 {
        t.as_i32()
    }
    pub trait AsI32 {
        fn as_i32(self) -> i32;
    }
    impl<'a, T: Copy + AsI32> AsI32 for &'a T {
        fn as_i32(self) -> i32 {
            (*self).as_i32()
        }
    }
    impl AsI32 for i32 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u32 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for i16 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u16 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for i8 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u8 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for char {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for usize {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    extern crate alloc as alloc_crate;
}
/// Generates `#[unsafe(no_mangle)]` functions to export the specified type as
/// the root implementation of all generated traits.
///
/// For more information see the documentation of `wit_bindgen::generate!`.
///
/// ```rust
/// # macro_rules! export{ ($($t:tt)*) => (); }
/// # trait Guest {}
/// struct MyType;
///
/// impl Guest for MyType {
///     // ...
/// }
///
/// export!(MyType);
/// ```
#[allow(unused_macros)]
#[doc(hidden)]
macro_rules! __export_dentdelion_plugin_impl {
    ($ty:ident) => {
        self::export!($ty with_types_in self);
    };
    ($ty:ident with_types_in $($path_to_types_root:tt)*) => {
        $($path_to_types_root)*::
        exports::reinhardt::dentdelion::plugin::__export_reinhardt_dentdelion_plugin_0_1_0_cabi!($ty
        with_types_in $($path_to_types_root)*:: exports::reinhardt::dentdelion::plugin);
    };
}
#[doc(inline)]
pub(crate) use __export_dentdelion_plugin_impl as export;
#[cfg(target_arch = "wasm32")]
#[unsafe(
    link_section = "component-type:wit-bindgen:0.41.0:reinhardt:dentdelion@0.1.0:dentdelion-plugin:encoded world"
)]
#[doc(hidden)]
#[allow(clippy::octal_escapes)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 1420] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\x84\x0a\x01A\x02\x01\
A\x0a\x01B\x0d\x01ks\x01ps\x01r\x07\x04names\x07versions\x0bdescription\0\x07aut\
hors\x01\x07license\0\x0arepository\0\x08homepage\0\x04\0\x0fplugin-metadata\x03\
\0\x02\x01q\x0e\x0amiddleware\0\0\x08commands\0\0\x09view-sets\0\0\x07signals\0\0\
\x08services\0\0\x04auth\0\0\x09templates\0\0\x0cstatic-files\0\0\x07routing\0\0\
\x10signal-receivers\0\0\x08handlers\0\0\x0enetwork-access\0\0\x0fdatabase-acces\
s\0\0\x06custom\x01s\0\x04\0\x0acapability\x03\0\x04\x01r\x03\x04codey\x07messag\
es\x07details\0\x04\0\x0cplugin-error\x03\0\x06\x01o\x02ss\x01p\x08\x01p}\x01r\x03\
\x06status{\x07headers\x09\x04body\x0a\x04\0\x0dhttp-response\x03\0\x0b\x03\0\x20\
reinhardt:dentdelion/types@0.1.0\x05\0\x02\x03\0\0\x0cplugin-error\x02\x03\0\0\x0d\
http-response\x01B#\x02\x03\x02\x01\x01\x04\0\x0cplugin-error\x03\0\0\x02\x03\x02\
\x01\x02\x04\0\x0dhttp-response\x03\0\x02\x01p}\x01k\x04\x01@\x01\x03keys\0\x05\x04\
\0\x0aget-config\x01\x06\x01j\0\x01\x01\x01@\x02\x03keys\x05value\x04\0\x07\x04\0\
\x0aset-config\x01\x08\x01@\x01\x07messages\x01\0\x04\0\x09log-debug\x01\x09\x04\
\0\x08log-info\x01\x09\x04\0\x08log-warn\x01\x09\x04\0\x09log-error\x01\x09\x01@\
\x02\x04names\x04data\x04\0\x07\x04\0\x10register-service\x01\x0a\x01@\x01\x04na\
mes\0\x05\x04\0\x0bget-service\x01\x0b\x01@\x01\x04names\0\x07\x04\0\x12unregist\
er-service\x01\x0c\x01o\x02ss\x01p\x0d\x01j\x01\x03\x01\x01\x01@\x02\x03urls\x07\
headers\x0e\0\x0f\x04\0\x08http-get\x01\x10\x01@\x03\x03urls\x04body\x04\x07head\
ers\x0e\0\x0f\x04\0\x09http-post\x01\x11\x01j\x01\x04\x01\x01\x01@\x02\x03sqls\x06\
params\x04\0\x12\x04\0\x08db-query\x01\x13\x01j\x01w\x01\x01\x01@\x02\x03sqls\x06\
params\x04\0\x14\x04\0\x0adb-execute\x01\x15\x03\0\x1freinhardt:dentdelion/host@\
0.1.0\x05\x03\x02\x03\0\0\x0fplugin-metadata\x02\x03\0\0\x0acapability\x01B\x13\x02\
\x03\x02\x01\x04\x04\0\x0fplugin-metadata\x03\0\0\x02\x03\x02\x01\x05\x04\0\x0ac\
apability\x03\0\x02\x02\x03\x02\x01\x01\x04\0\x0cplugin-error\x03\0\x04\x01@\0\0\
\x01\x04\0\x0cget-metadata\x01\x06\x01p\x03\x01@\0\0\x07\x04\0\x10get-capabiliti\
es\x01\x08\x01p}\x01j\0\x01\x05\x01@\x01\x06config\x09\0\x0a\x04\0\x07on-load\x01\
\x0b\x01@\0\0\x0a\x04\0\x09on-enable\x01\x0c\x04\0\x0aon-disable\x01\x0c\x04\0\x09\
on-unload\x01\x0c\x04\0!reinhardt:dentdelion/plugin@0.1.0\x05\x06\x04\0,reinhard\
t:dentdelion/dentdelion-plugin@0.1.0\x04\0\x0b\x17\x01\0\x11dentdelion-plugin\x03\
\0\0\0G\x09producers\x01\x0cprocessed-by\x02\x0dwit-component\x070.227.1\x10wit-\
bindgen-rust\x060.41.0";
#[inline(never)]
#[doc(hidden)]
pub fn __link_custom_section_describing_imports() {
    wit_bindgen_rt::maybe_link_cabi_realloc();
}
