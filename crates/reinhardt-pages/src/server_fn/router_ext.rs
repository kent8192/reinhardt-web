//! Server Function Router Extension
//!
//! This module provides the `ServerFnRouterExt` extension trait for registering
//! server functions explicitly with `ServerRouter`.
//!
//! ## Usage
//!
//! ```ignore
//! use reinhardt::pages::server_fn::ServerFnRouterExt;
//! use crate::server_fn::{login, logout, get_user};
//!
//! pub fn routes() -> ServerRouter {
//!     ServerRouter::new()
//!         .server_fn(login)
//!         .server_fn(logout)
//!         .server_fn(get_user)
//! }
//! ```

use super::registration::ServerFnRegistration;
use super::ServerFnError;
use hyper::{Method, StatusCode};
use reinhardt_http::{Request, Response};
use reinhardt_routers::ServerRouter;
use std::future::Future;
use std::pin::Pin;

/// Extension trait for registering server functions with `ServerRouter`.
///
/// This trait provides the `server_fn` method which allows explicit registration
/// of server functions. Unlike the previous `register_all_server_functions()`
/// approach, this makes the registration explicit and visible.
///
/// # Example
///
/// ```ignore
/// use reinhardt::pages::server_fn::ServerFnRouterExt;
/// use crate::server_fn::{login, logout};
///
/// let router = ServerRouter::new()
///     .server_fn(login)    // Explicitly register login
///     .server_fn(logout);  // Explicitly register logout
/// ```
///
/// # Benefits
///
/// - **Explicit**: Clearly shows which server functions are registered
/// - **Type-safe**: Compiler ensures only valid server functions are passed
/// - **IDE-friendly**: Auto-completion and go-to-definition work correctly
/// - **Controllable**: Prevents accidental registration of server functions
pub trait ServerFnRouterExt {
	/// Register a server function with this router.
	///
	/// The server function must have been defined with the `#[server_fn]` macro,
	/// which generates the marker struct passed as the `marker` argument.
	///
	/// # Arguments
	///
	/// * `marker` - The marker struct generated by `#[server_fn]` macro
	///
	/// # Returns
	///
	/// Returns `self` with the server function registered, allowing method chaining.
	///
	/// # Example
	///
	/// ```ignore
	/// use reinhardt::pages::server_fn::ServerFnRouterExt;
	/// use crate::server_fn::login;
	///
	/// let router = ServerRouter::new()
	///     .server_fn(login);
	/// ```
	fn server_fn<S: ServerFnRegistration>(self, marker: S) -> Self;
}

impl ServerFnRouterExt for ServerRouter {
	fn server_fn<S: ServerFnRegistration>(self, _marker: S) -> Self {
		let handler = S::handler();
		let path = S::PATH;
		let name = S::NAME;

		let wrapper = move |req: Request| -> Pin<
			Box<dyn Future<Output = Result<Response, reinhardt_http::Error>> + Send>,
		> {
			Box::pin(async move {
				match handler(req).await {
					Ok(body) => Ok(Response::ok()
						.with_header("Content-Type", "application/json")
						.with_body(body)),
					Err(error_body) => {
						// Log the error to stderr for debugging
						eprintln!("[server_fn ERROR] {} ({}): {}", name, path, error_body);

						// Extract status code from ServerFnError if possible
						let status_code = serde_json::from_str::<ServerFnError>(&error_body)
							.ok()
							.map(|err| match err {
								ServerFnError::Server { status, .. } => StatusCode::from_u16(status)
									.unwrap_or(StatusCode::INTERNAL_SERVER_ERROR),
								_ => StatusCode::INTERNAL_SERVER_ERROR,
							})
							.unwrap_or(StatusCode::INTERNAL_SERVER_ERROR);

						Ok(Response::new(status_code)
							.with_header("Content-Type", "application/json")
							.with_body(error_body))
					}
				}
			})
		};

		self.function(path, Method::POST, wrapper)
	}
}
