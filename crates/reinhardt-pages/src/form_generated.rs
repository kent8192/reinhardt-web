//! Static Metadata Types for form! Macro Generated Code
//!
//! This module is always available (on both WASM and server) because it only
//! depends on `serde`. It provides metadata structures specifically designed
//! for the form! macro.
//!
//! Unlike `FormMetadata` from `reinhardt-forms::wasm_compat` which is extracted from
//! runtime Form instances, these types are generated at compile-time and include
//! additional styling and action information.
//!
//! ## Design Decision
//!
//! The form! macro generates static forms with compile-time known structure,
//! which allows for:
//! - Direct action URL and method specification
//! - CSS class customization at the form and field level
//! - Type-safe field accessors
//!
//! ## Example
//!
//! ```ignore
//! use reinhardt_pages::form;
//!
//! let login_form = form! {
//!     name: LoginForm,
//!     action: "/api/login",
//!     class: "login-form",
//!
//!     fields: {
//!         username: CharField { required, class: "input-field" },
//!         password: CharField { widget: PasswordInput },
//!     },
//! };
//!
//! // Access metadata
//! let metadata = login_form.metadata();
//! assert_eq!(metadata.action, "/api/login");
//! ```

use serde::{Deserialize, Serialize};

/// Static form metadata for macro-generated forms.
///
/// This structure contains all information needed to render a form
/// generated by the form! macro.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StaticFormMetadata {
	/// Form action URL or server function path
	pub action: String,

	/// HTTP method (GET, POST, PUT, PATCH, DELETE)
	pub method: String,

	/// CSS class for the form element
	pub class: String,

	/// Field metadata list
	pub fields: Vec<StaticFieldMetadata>,
}

impl StaticFormMetadata {
	/// Creates a new StaticFormMetadata.
	pub fn new(
		action: impl Into<String>,
		method: impl Into<String>,
		class: impl Into<String>,
	) -> Self {
		Self {
			action: action.into(),
			method: method.into(),
			class: class.into(),
			fields: Vec::new(),
		}
	}

	/// Adds a field to the metadata.
	pub fn with_field(mut self, field: StaticFieldMetadata) -> Self {
		self.fields.push(field);
		self
	}

	/// Adds multiple fields to the metadata.
	pub fn with_fields(mut self, fields: Vec<StaticFieldMetadata>) -> Self {
		self.fields = fields;
		self
	}
}

/// Static field metadata for macro-generated forms.
///
/// This structure contains all information needed to render a single form field,
/// including styling attributes that are specified at compile-time.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StaticFieldMetadata {
	/// Field name (used as form data key and HTML name attribute)
	pub name: String,

	/// Field type identifier (e.g., "CharField", "IntegerField")
	pub field_type: String,

	/// Widget type identifier (e.g., "TextInput", "PasswordInput")
	pub widget: String,

	/// Whether the field is required
	pub required: bool,

	/// Human-readable label
	pub label: String,

	/// Placeholder text for input elements
	pub placeholder: String,

	/// CSS class for the input element
	pub input_class: String,

	/// CSS class for the wrapper div element
	pub wrapper_class: String,

	/// CSS class for the label element
	pub label_class: String,

	/// CSS class for error message elements
	pub error_class: String,
}

impl StaticFieldMetadata {
	/// Creates a new StaticFieldMetadata with default styling.
	pub fn new(name: impl Into<String>, field_type: impl Into<String>) -> Self {
		let name_str = name.into();
		Self {
			label: name_str.clone(),
			name: name_str,
			field_type: field_type.into(),
			widget: "TextInput".to_string(),
			required: false,
			placeholder: String::new(),
			input_class: "reinhardt-input".to_string(),
			wrapper_class: "reinhardt-field".to_string(),
			label_class: "reinhardt-label".to_string(),
			error_class: "reinhardt-error".to_string(),
		}
	}

	/// Sets the widget type.
	pub fn with_widget(mut self, widget: impl Into<String>) -> Self {
		self.widget = widget.into();
		self
	}

	/// Sets the required flag.
	pub fn with_required(mut self, required: bool) -> Self {
		self.required = required;
		self
	}

	/// Sets the label.
	pub fn with_label(mut self, label: impl Into<String>) -> Self {
		self.label = label.into();
		self
	}

	/// Sets the placeholder.
	pub fn with_placeholder(mut self, placeholder: impl Into<String>) -> Self {
		self.placeholder = placeholder.into();
		self
	}

	/// Sets the input CSS class.
	pub fn with_input_class(mut self, class: impl Into<String>) -> Self {
		self.input_class = class.into();
		self
	}

	/// Sets the wrapper CSS class.
	pub fn with_wrapper_class(mut self, class: impl Into<String>) -> Self {
		self.wrapper_class = class.into();
		self
	}

	/// Sets the label CSS class.
	pub fn with_label_class(mut self, class: impl Into<String>) -> Self {
		self.label_class = class.into();
		self
	}

	/// Sets the error CSS class.
	pub fn with_error_class(mut self, class: impl Into<String>) -> Self {
		self.error_class = class.into();
		self
	}
}

#[cfg(test)]
mod tests {
	use super::*;
	use rstest::rstest;

	#[rstest]
	fn test_static_form_metadata_creation() {
		let form = StaticFormMetadata::new("/api/login", "POST", "login-form");

		assert_eq!(form.action, "/api/login");
		assert_eq!(form.method, "POST");
		assert_eq!(form.class, "login-form");
		assert!(form.fields.is_empty());
	}

	#[rstest]
	fn test_static_form_metadata_with_fields() {
		let form = StaticFormMetadata::new("/api/submit", "POST", "my-form").with_fields(vec![
			StaticFieldMetadata::new("username", "CharField").with_required(true),
			StaticFieldMetadata::new("email", "EmailField"),
		]);

		assert_eq!(form.fields.len(), 2);
		assert_eq!(form.fields[0].name, "username");
		assert!(form.fields[0].required);
		assert_eq!(form.fields[1].name, "email");
		assert!(!form.fields[1].required);
	}

	#[rstest]
	fn test_static_field_metadata_defaults() {
		let field = StaticFieldMetadata::new("test_field", "CharField");

		assert_eq!(field.name, "test_field");
		assert_eq!(field.label, "test_field");
		assert_eq!(field.field_type, "CharField");
		assert_eq!(field.widget, "TextInput");
		assert!(!field.required);
		assert!(field.placeholder.is_empty());
		assert_eq!(field.input_class, "reinhardt-input");
		assert_eq!(field.wrapper_class, "reinhardt-field");
		assert_eq!(field.label_class, "reinhardt-label");
		assert_eq!(field.error_class, "reinhardt-error");
	}

	#[rstest]
	fn test_static_field_metadata_customization() {
		let field = StaticFieldMetadata::new("email", "EmailField")
			.with_widget("EmailInput")
			.with_required(true)
			.with_label("Email Address")
			.with_placeholder("Enter your email")
			.with_input_class("custom-input")
			.with_wrapper_class("custom-wrapper");

		assert_eq!(field.name, "email");
		assert_eq!(field.label, "Email Address");
		assert_eq!(field.widget, "EmailInput");
		assert!(field.required);
		assert_eq!(field.placeholder, "Enter your email");
		assert_eq!(field.input_class, "custom-input");
		assert_eq!(field.wrapper_class, "custom-wrapper");
	}

	#[rstest]
	fn test_static_metadata_serialization() {
		let form = StaticFormMetadata::new("/api/test", "POST", "test-form")
			.with_field(StaticFieldMetadata::new("name", "CharField").with_required(true));

		let json = serde_json::to_string(&form).expect("Failed to serialize");
		assert!(json.contains("\"action\":\"/api/test\""));
		assert!(json.contains("\"name\":\"name\""));

		let deserialized: StaticFormMetadata =
			serde_json::from_str(&json).expect("Failed to deserialize");
		assert_eq!(deserialized.action, "/api/test");
		assert_eq!(deserialized.fields.len(), 1);
	}
}
