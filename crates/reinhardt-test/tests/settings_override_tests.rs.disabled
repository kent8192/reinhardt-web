//! Tests for settings override utilities
//!
//! These tests verify settings override functionality including:
//! - Temporary settings override
//! - Settings restoration
//! - Nested overrides
//! - Thread-local overrides
//!
//! Based on Django's override_settings decorator

use std::collections::HashMap;
use std::sync::{Arc, Mutex};

/// Simple settings manager for testing
struct SettingsManager {
    settings: Arc<Mutex<HashMap<String, String>>>,
}

impl SettingsManager {
    fn new() -> Self {
        let mut settings = HashMap::new();
        settings.insert("DEBUG".to_string(), "false".to_string());
        settings.insert(
            "DATABASE_URL".to_string(),
            "postgres://localhost".to_string(),
        );
        settings.insert("SECRET_KEY".to_string(), "default_secret".to_string());

        Self {
            settings: Arc::new(Mutex::new(settings)),
        }
    }

    fn get(&self, key: &str) -> Option<String> {
        self.settings.lock().unwrap().get(key).cloned()
    }

    fn set(&self, key: &str, value: &str) {
        self.settings
            .lock()
            .unwrap()
            .insert(key.to_string(), value.to_string());
    }

    fn override_with<F, R>(&self, key: &str, value: &str, f: F) -> R
    where
        F: FnOnce() -> R,
    {
        let original = self.get(key);
        self.set(key, value);
        let result = f();
        if let Some(orig) = original {
            self.set(key, &orig);
        }
        result
    }
}

#[test]
fn test_settings_get() {
    // Test: Get setting value
    let manager = SettingsManager::new();

    assert_eq!(manager.get("DEBUG"), Some("false".to_string()));
    assert_eq!(
        manager.get("DATABASE_URL"),
        Some("postgres://localhost".to_string())
    );
}

#[test]
fn test_settings_set() {
    // Test: Set setting value
    let manager = SettingsManager::new();

    manager.set("DEBUG", "true");
    assert_eq!(manager.get("DEBUG"), Some("true".to_string()));
}

#[test]
fn test_settings_override_temporary() {
    // Test: Temporary settings override
    let manager = SettingsManager::new();

    let original = manager.get("DEBUG");
    assert_eq!(original, Some("false".to_string()));

    // Override temporarily
    manager.override_with("DEBUG", "true", || {
        assert_eq!(manager.get("DEBUG"), Some("true".to_string()));
    });

    // Setting should be restored
    assert_eq!(manager.get("DEBUG"), Some("false".to_string()));
}

#[test]
fn test_settings_override_nested() {
    // Test: Nested settings overrides
    let manager = SettingsManager::new();

    manager.override_with("DEBUG", "true", || {
        assert_eq!(manager.get("DEBUG"), Some("true".to_string()));

        manager.override_with("DEBUG", "verbose", || {
            assert_eq!(manager.get("DEBUG"), Some("verbose".to_string()));
        });

        // Inner override restored
        assert_eq!(manager.get("DEBUG"), Some("true".to_string()));
    });

    // Outer override restored
    assert_eq!(manager.get("DEBUG"), Some("false".to_string()));
}

#[test]
fn test_settings_override_multiple() {
    // Test: Override multiple settings
    let manager = SettingsManager::new();

    let debug_orig = manager.get("DEBUG");
    let secret_orig = manager.get("SECRET_KEY");

    manager.set("DEBUG", "true");
    manager.set("SECRET_KEY", "test_secret");

    assert_eq!(manager.get("DEBUG"), Some("true".to_string()));
    assert_eq!(manager.get("SECRET_KEY"), Some("test_secret".to_string()));

    // Restore originals
    if let Some(orig) = debug_orig {
        manager.set("DEBUG", &orig);
    }
    if let Some(orig) = secret_orig {
        manager.set("SECRET_KEY", &orig);
    }

    assert_eq!(manager.get("DEBUG"), Some("false".to_string()));
    assert_eq!(
        manager.get("SECRET_KEY"),
        Some("default_secret".to_string())
    );
}

#[test]
fn test_settings_override_with_return_value() {
    // Test: Override returns function result
    let manager = SettingsManager::new();

    let result = manager.override_with("DEBUG", "true", || 42);

    assert_eq!(result, 42);
    assert_eq!(manager.get("DEBUG"), Some("false".to_string()));
}

#[test]
fn test_settings_missing_key() {
    // Test: Get non-existent setting
    let manager = SettingsManager::new();

    assert_eq!(manager.get("NON_EXISTENT"), None);
}

#[test]
fn test_settings_override_new_key() {
    // Test: Override creates new key temporarily
    let manager = SettingsManager::new();

    assert_eq!(manager.get("NEW_KEY"), None);

    manager.set("NEW_KEY", "temporary_value");
    assert_eq!(manager.get("NEW_KEY"), Some("temporary_value".to_string()));
}

#[test]
fn test_settings_thread_safety() {
    // Test: Settings are thread-safe
    let manager = Arc::new(SettingsManager::new());

    let manager_clone = Arc::clone(&manager);
    let handle = std::thread::spawn(move || {
        manager_clone.set("THREAD_TEST", "from_thread");
        manager_clone.get("THREAD_TEST")
    });

    let result = handle.join().unwrap();
    assert_eq!(result, Some("from_thread".to_string()));
}

#[test]
fn test_settings_override_exception_safety() {
    // Test: Settings restored even if function panics
    let manager = SettingsManager::new();

    let original = manager.get("DEBUG");

    let _ = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        manager.set("DEBUG", "true");
        panic!("Test panic");
    }));

    // In a real implementation, this would use Drop trait
    // For this test, we manually restore
    if let Some(orig) = original {
        manager.set("DEBUG", &orig);
    }

    assert_eq!(manager.get("DEBUG"), Some("false".to_string()));
}

#[test]
fn test_settings_override_empty_value() {
    // Test: Override with empty string
    let manager = SettingsManager::new();

    manager.override_with("DEBUG", "", || {
        assert_eq!(manager.get("DEBUG"), Some("".to_string()));
    });

    assert_eq!(manager.get("DEBUG"), Some("false".to_string()));
}

#[test]
fn test_settings_concurrent_overrides() {
    // Test: Concurrent setting modifications
    use std::sync::atomic::{AtomicUsize, Ordering};

    let manager = Arc::new(SettingsManager::new());
    let counter = Arc::new(AtomicUsize::new(0));

    let handles: Vec<_> = (0..5)
        .map(|i| {
            let manager_clone = Arc::clone(&manager);
            let counter_clone = Arc::clone(&counter);
            std::thread::spawn(move || {
                manager_clone.set("COUNTER", &i.to_string());
                counter_clone.fetch_add(1, Ordering::SeqCst);
            })
        })
        .collect();

    for handle in handles {
        handle.join().unwrap();
    }

    assert_eq!(counter.load(Ordering::SeqCst), 5);
}

#[test]
fn test_settings_override_pattern() {
    // Test: Settings override pattern (context manager style)
    struct SettingsOverride<'a> {
        manager: &'a SettingsManager,
        key: String,
        original: Option<String>,
    }

    impl<'a> SettingsOverride<'a> {
        fn new(manager: &'a SettingsManager, key: &str, value: &str) -> Self {
            let original = manager.get(key);
            manager.set(key, value);
            Self {
                manager,
                key: key.to_string(),
                original,
            }
        }
    }

    impl<'a> Drop for SettingsOverride<'a> {
        fn drop(&mut self) {
            if let Some(ref orig) = self.original {
                self.manager.set(&self.key, orig);
            }
        }
    }

    let manager = SettingsManager::new();

    {
        let _override = SettingsOverride::new(&manager, "DEBUG", "true");
        assert_eq!(manager.get("DEBUG"), Some("true".to_string()));
    }

    // Should be restored after drop
    assert_eq!(manager.get("DEBUG"), Some("false".to_string()));
}

#[test]
fn test_settings_bulk_override() {
    // Test: Override multiple settings at once
    let manager = SettingsManager::new();

    let overrides = vec![
        ("DEBUG", "true"),
        ("SECRET_KEY", "test_key"),
        ("DATABASE_URL", "sqlite::memory:"),
    ];

    // Save originals
    let originals: Vec<_> = overrides
        .iter()
        .map(|(key, _)| (*key, manager.get(key)))
        .collect();

    // Apply overrides
    for (key, value) in &overrides {
        manager.set(key, value);
    }

    assert_eq!(manager.get("DEBUG"), Some("true".to_string()));
    assert_eq!(manager.get("SECRET_KEY"), Some("test_key".to_string()));

    // Restore originals
    for (key, original) in originals {
        if let Some(orig) = original {
            manager.set(key, &orig);
        }
    }
}

#[test]
fn test_settings_override_chaining() {
    // Test: Chain multiple overrides
    let manager = SettingsManager::new();

    manager.override_with("DEBUG", "level1", || {
        manager.override_with("SECRET_KEY", "secret1", || {
            assert_eq!(manager.get("DEBUG"), Some("level1".to_string()));
            assert_eq!(manager.get("SECRET_KEY"), Some("secret1".to_string()));
        });
    });

    assert_eq!(manager.get("DEBUG"), Some("false".to_string()));
    assert_eq!(
        manager.get("SECRET_KEY"),
        Some("default_secret".to_string())
    );
}

#[test]
fn test_settings_numeric_values() {
    // Test: Settings with numeric values (as strings)
    let manager = SettingsManager::new();

    manager.set("PORT", "8080");
    manager.set("TIMEOUT", "30");

    assert_eq!(manager.get("PORT"), Some("8080".to_string()));
    assert_eq!(manager.get("TIMEOUT"), Some("30".to_string()));
}

#[test]
fn test_settings_boolean_values() {
    // Test: Settings with boolean values (as strings)
    let manager = SettingsManager::new();

    manager.set("ENABLE_CACHE", "true");
    manager.set("DEBUG_SQL", "false");

    assert_eq!(manager.get("ENABLE_CACHE"), Some("true".to_string()));
    assert_eq!(manager.get("DEBUG_SQL"), Some("false".to_string()));
}

#[test]
fn test_settings_override_isolation() {
    // Test: Overrides are isolated to their scope
    let manager = SettingsManager::new();

    let value_before = manager.get("DEBUG");

    {
        manager.override_with("DEBUG", "temp", || {
            assert_eq!(manager.get("DEBUG"), Some("temp".to_string()));
        });
    }

    assert_eq!(manager.get("DEBUG"), value_before);
}

#[test]
fn test_settings_clone_semantics() {
    // Test: Settings values are properly cloned
    let manager = SettingsManager::new();

    let value1 = manager.get("DEBUG").unwrap();
    let value2 = manager.get("DEBUG").unwrap();

    assert_eq!(value1, value2);
    assert_eq!(value1, "false".to_string());
}
