//! Advanced proxy functionality tests
//!
//! These tests are based on reinhardt-proxy capabilities and test advanced
//! association proxy features like chaining, aliases, serialization, and
//! complex relationship handling.

use reinhardt_proxy::{
    AssociationProxy, CollectionProxy, JoinConfig, LoadingStrategy, NestedProxy, ProxyBuilder,
    ProxyError, ProxyResult, ProxyTarget, RelationshipPath, ScalarProxy, ScalarValue,
};
use reinhardt_test::TestCase;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

/// Test models for proxy testing
#[derive(Debug, Clone, Serialize, Deserialize)]
struct User {
    id: Option<i64>,
    name: String,
    email: String,
    posts: Vec<Post>,
    roles: Vec<Role>,
    profile: Option<UserProfile>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
struct Post {
    id: Option<i64>,
    user_id: i64,
    title: String,
    content: String,
    comments: Vec<Comment>,
    tags: Vec<Tag>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
struct Comment {
    id: Option<i64>,
    post_id: i64,
    author_id: i64,
    content: String,
    author: Option<User>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
struct Tag {
    id: Option<i64>,
    name: String,
    posts: Vec<Post>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
struct Role {
    id: Option<i64>,
    name: String,
    permissions: Vec<Permission>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
struct Permission {
    id: Option<i64>,
    name: String,
    resource: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
struct UserProfile {
    id: Option<i64>,
    user_id: i64,
    bio: String,
    avatar_url: Option<String>,
}

/// Mock proxy accessor for testing
struct MockProxyAccessor;

#[async_trait::async_trait]
impl<T> reinhardt_proxy::ProxyAccessor<T> for MockProxyAccessor {
    async fn get(&self, _source: &T) -> ProxyResult<ProxyTarget> {
        Ok(ProxyTarget::Collection(vec![
            ScalarValue::String("test_value".to_string()),
            ScalarValue::Integer(42),
        ]))
    }

    async fn set(&self, _source: &mut T, _value: ProxyTarget) -> ProxyResult<()> {
        Ok(())
    }
}

#[tokio::test]
async fn test_proxy_chain_basic() {
    let mut test_case = TestCase::new();

    // Create a proxy chain: user.posts.comments.author.name
    let posts_proxy = AssociationProxy::new("posts", "id");
    let comments_proxy = AssociationProxy::new("comments", "author");
    let author_proxy = AssociationProxy::new("author", "name");

    // Test chain creation
    let chain = RelationshipPath::new()
        .through("posts")
        .through("comments")
        .through("author")
        .attribute("name");

    assert_eq!(chain.path().len(), 3);
    assert_eq!(chain.attribute(), "name");

    test_case.cleanup().await;
}

#[tokio::test]
async fn test_proxy_chain_with_filter() {
    let mut test_case = TestCase::new();

    // Create chain with filter at intermediate level
    let chain = RelationshipPath::new()
        .through("posts")
        .with_filter("published", "true")
        .through("comments")
        .through("author")
        .attribute("name");

    assert!(chain.has_filters());
    assert_eq!(chain.filters().len(), 1);

    test_case.cleanup().await;
}

#[tokio::test]
async fn test_proxy_chain_with_transform() {
    let mut test_case = TestCase::new();

    // Create chain with transformation
    let chain = RelationshipPath::new()
        .through("posts")
        .through("comments")
        .with_transform("author", "upper")
        .attribute("name");

    assert!(chain.has_transforms());
    assert_eq!(chain.transforms().len(), 1);

    test_case.cleanup().await;
}

#[tokio::test]
async fn test_proxy_chain_circular_detection() {
    let mut test_case = TestCase::new();

    // Test circular reference detection
    let chain = RelationshipPath::new()
        .through("posts")
        .through("author")
        .through("posts"); // This should be detected as circular

    // In a real implementation, this would detect the circular reference
    // For now, we just test that the chain is created
    assert_eq!(chain.path().len(), 3);

    test_case.cleanup().await;
}

#[tokio::test]
async fn test_proxy_alias_basic() {
    let mut test_case = TestCase::new();

    // Create proxy alias for keyword strings
    let alias = ProxyBuilder::new("keyword_strings")
        .for_relationship("keywords")
        .attribute("name")
        .build();

    assert_eq!(alias.name(), "keyword_strings");
    assert_eq!(alias.relationship(), "keywords");
    assert_eq!(alias.attribute(), "name");

    test_case.cleanup().await;
}

#[tokio::test]
async fn test_proxy_alias_custom_accessor() {
    let mut test_case = TestCase::new();

    // Create alias with custom getter/setter
    let alias = ProxyBuilder::new("custom_field")
        .for_relationship("data")
        .attribute("value")
        .with_getter(|_obj| Ok(ScalarValue::String("custom".to_string())))
        .with_setter(|_obj, _value| Ok(()))
        .build();

    assert_eq!(alias.name(), "custom_field");
    assert!(alias.has_custom_accessors());

    test_case.cleanup().await;
}

#[tokio::test]
async fn test_proxy_alias_with_validation() {
    let mut test_case = TestCase::new();

    // Create alias with validation
    let alias = ProxyBuilder::new("validated_field")
        .for_relationship("data")
        .attribute("value")
        .with_validator(|value| {
            if let ScalarValue::String(s) = value {
                if s.len() > 10 {
                    Err(ProxyError::InvalidConfiguration(
                        "Value too long".to_string(),
                    ))
                } else {
                    Ok(())
                }
            } else {
                Ok(())
            }
        })
        .build();

    assert_eq!(alias.name(), "validated_field");
    assert!(alias.has_validator());

    test_case.cleanup().await;
}

#[tokio::test]
async fn test_proxy_alias_with_transform() {
    let mut test_case = TestCase::new();

    // Create alias with transformation
    let alias = ProxyBuilder::new("transformed_field")
        .for_relationship("data")
        .attribute("value")
        .with_transform(|value| match value {
            ScalarValue::String(s) => ScalarValue::String(s.to_uppercase()),
            other => other,
        })
        .build();

    assert_eq!(alias.name(), "transformed_field");
    assert!(alias.has_transform());

    test_case.cleanup().await;
}

#[tokio::test]
async fn test_proxy_alias_serialization() {
    let mut test_case = TestCase::new();

    // Test alias serialization to JSON
    let alias = ProxyBuilder::new("serializable_field")
        .for_relationship("data")
        .attribute("value")
        .build();

    let json = serde_json::to_string(&alias).unwrap();
    assert!(json.contains("serializable_field"));
    assert!(json.contains("data"));
    assert!(json.contains("value"));

    test_case.cleanup().await;
}

#[tokio::test]
async fn test_proxy_serialization() {
    let mut test_case = TestCase::new();

    // Test proxy serialization to JSON
    let proxy = CollectionProxy::new("posts", "title")
        .with_unique(true)
        .with_loading_strategy(LoadingStrategy::Joined);

    let json = serde_json::to_string(&proxy).unwrap();
    assert!(json.contains("\"relationship\":\"posts\""));
    assert!(json.contains("\"attribute\":\"title\""));
    assert!(json.contains("\"unique\":true"));

    test_case.cleanup().await;
}

#[tokio::test]
async fn test_proxy_deserialization() {
    let mut test_case = TestCase::new();

    // Test proxy deserialization from JSON
    let json =
        r#"{"relationship":"posts","attribute":"title","unique":true,"loading_strategy":"lazy"}"#;
    let proxy: CollectionProxy = serde_json::from_str(json).unwrap();

    assert_eq!(proxy.relationship(), "posts");
    assert_eq!(proxy.attribute(), "title");
    assert!(proxy.is_unique());

    test_case.cleanup().await;
}

#[tokio::test]
async fn test_proxy_config_serialization() {
    let mut test_case = TestCase::new();

    // Test proxy configuration serialization
    let config = JoinConfig::new()
        .with_loading_strategy(LoadingStrategy::Joined)
        .with_join_type("LEFT JOIN")
        .with_condition("users.id = posts.user_id");

    let json = serde_json::to_string(&config).unwrap();
    assert!(json.contains("joined"));
    assert!(json.contains("LEFT JOIN"));

    test_case.cleanup().await;
}

#[tokio::test]
async fn test_proxy_null_relationship() {
    let mut test_case = TestCase::new();

    // Test proxy with None/null relationships
    let user = User {
        id: Some(1),
        name: "Test User".to_string(),
        email: "test@example.com".to_string(),
        posts: vec![],
        roles: vec![],
        profile: None, // Null relationship
    };

    let proxy = ScalarProxy::new("profile", "bio");
    let result = proxy.get_value(&user).await;

    // Should handle null relationship gracefully
    match result {
        Ok(ScalarValue::Null) => {} // Expected for null relationship
        Ok(_) => panic!("Expected null value for null relationship"),
        Err(_) => {} // Also acceptable - depends on implementation
    }

    test_case.cleanup().await;
}

#[tokio::test]
async fn test_proxy_empty_collection() {
    let mut test_case = TestCase::new();

    // Test proxy with empty collections
    let user = User {
        id: Some(1),
        name: "Test User".to_string(),
        email: "test@example.com".to_string(),
        posts: vec![], // Empty collection
        roles: vec![],
        profile: None,
    };

    let proxy = CollectionProxy::new("posts", "title");
    let result = proxy.get_values(&user).await;

    match result {
        Ok(values) => {
            assert!(values.is_empty());
        }
        Err(_) => {} // Also acceptable - depends on implementation
    }

    test_case.cleanup().await;
}

#[tokio::test]
async fn test_proxy_duplicates_handling() {
    let mut test_case = TestCase::new();

    // Test proxy with duplicate values
    let proxy = CollectionProxy::new("tags", "name")
        .with_unique(false) // Allow duplicates
        .with_deduplication(false);

    assert!(!proxy.is_unique());
    assert!(!proxy.deduplicates());

    test_case.cleanup().await;
}

#[tokio::test]
async fn test_nested_proxy_basic() {
    let mut test_case = TestCase::new();

    // Test nested proxy functionality
    let nested_proxy = NestedProxy::new()
        .add_level("posts")
        .add_level("comments")
        .add_level("author")
        .attribute("name");

    assert_eq!(nested_proxy.depth(), 3);
    assert_eq!(nested_proxy.attribute(), "name");

    test_case.cleanup().await;
}

#[tokio::test]
async fn test_nested_proxy_with_conditions() {
    let mut test_case = TestCase::new();

    // Test nested proxy with conditions
    let nested_proxy = NestedProxy::new()
        .add_level("posts")
        .with_condition("published = true")
        .add_level("comments")
        .with_condition("approved = true")
        .add_level("author")
        .attribute("name");

    assert_eq!(nested_proxy.depth(), 3);
    assert_eq!(nested_proxy.conditions().len(), 2);

    test_case.cleanup().await;
}

#[tokio::test]
async fn test_proxy_error_handling() {
    let mut test_case = TestCase::new();

    // Test proxy error handling
    let proxy = AssociationProxy::new("nonexistent", "attribute");

    // This should fail gracefully
    let result = proxy.get(&MockProxyAccessor).await;
    match result {
        Ok(_) => {} // Mock returns success
        Err(ProxyError::RelationshipNotFound(name)) => {
            assert_eq!(name, "nonexistent");
        }
        Err(_) => {} // Other errors are also acceptable
    }

    test_case.cleanup().await;
}

#[tokio::test]
async fn test_proxy_type_safety() {
    let mut test_case = TestCase::new();

    // Test proxy type safety
    let proxy = ScalarProxy::new("profile", "age");

    // Test type conversion
    let string_value = ScalarValue::String("25".to_string());
    let int_value = ScalarValue::Integer(25);

    assert!(string_value.as_string().is_ok());
    assert!(int_value.as_integer().is_ok());
    assert!(string_value.as_integer().is_err());
    assert!(int_value.as_string().is_err());

    test_case.cleanup().await;
}

#[tokio::test]
async fn test_proxy_performance_optimization() {
    let mut test_case = TestCase::new();

    // Test proxy performance optimization features
    let proxy = CollectionProxy::new("posts", "title")
        .with_loading_strategy(LoadingStrategy::Selectin) // Optimized loading
        .with_caching(true)
        .with_lazy_evaluation(true);

    assert_eq!(proxy.loading_strategy(), LoadingStrategy::Selectin);
    assert!(proxy.is_cached());
    assert!(proxy.is_lazy());

    test_case.cleanup().await;
}

#[tokio::test]
async fn test_proxy_memory_management() {
    let mut test_case = TestCase::new();

    // Test proxy memory management
    let proxy = CollectionProxy::new("large_collection", "data")
        .with_memory_limit(1024 * 1024) // 1MB limit
        .with_chunk_size(100)
        .with_streaming(true);

    assert_eq!(proxy.memory_limit(), Some(1024 * 1024));
    assert_eq!(proxy.chunk_size(), Some(100));
    assert!(proxy.is_streaming());

    test_case.cleanup().await;
}

#[tokio::test]
async fn test_proxy_concurrent_access() {
    let mut test_case = TestCase::new();

    // Test proxy concurrent access
    let proxy = CollectionProxy::new("concurrent_data", "value")
        .with_thread_safety(true)
        .with_mutex_protection(true);

    assert!(proxy.is_thread_safe());
    assert!(proxy.has_mutex_protection());

    test_case.cleanup().await;
}

#[tokio::test]
async fn test_proxy_batch_operations() {
    let mut test_case = TestCase::new();

    // Test proxy batch operations
    let proxy = CollectionProxy::new("batch_data", "value")
        .with_batch_size(50)
        .with_batch_timeout(5000) // 5 seconds
        .with_auto_flush(true);

    assert_eq!(proxy.batch_size(), Some(50));
    assert_eq!(proxy.batch_timeout(), Some(5000));
    assert!(proxy.auto_flushes());

    test_case.cleanup().await;
}

#[tokio::test]
async fn test_proxy_metrics_and_monitoring() {
    let mut test_case = TestCase::new();

    // Test proxy metrics and monitoring
    let proxy = CollectionProxy::new("monitored_data", "value")
        .with_metrics(true)
        .with_performance_tracking(true)
        .with_error_logging(true);

    assert!(proxy.has_metrics());
    assert!(proxy.tracks_performance());
    assert!(proxy.logs_errors());

    test_case.cleanup().await;
}
