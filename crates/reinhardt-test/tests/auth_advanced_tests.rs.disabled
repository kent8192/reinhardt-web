use reinhardt_auth::*;
use reinhardt_test::*;
use serde_json::json;
use std::collections::HashMap;
use std::sync::{Arc, Mutex};

/// Test JWT authentication with token generation and validation
#[tokio::test]
async fn test_jwt_authentication_flow() {
    let jwt_auth = JwtAuth::new(b"test_secret_key_32_bytes_long");
    let user_id = "user123".to_string();
    let username = "testuser".to_string();

    // Generate token
    let token = jwt_auth
        .generate_token(user_id.clone(), username.clone())
        .unwrap();
    assert!(!token.is_empty());

    // Validate token
    let claims = jwt_auth.validate_token(&token).unwrap();
    assert_eq!(claims.user_id, user_id);
    assert_eq!(claims.username, username);
}

/// Test JWT token expiration
#[tokio::test]
async fn test_jwt_token_expiration() {
    let jwt_auth = JwtAuth::new(b"test_secret_key_32_bytes_long");
    let user_id = "user123".to_string();
    let username = "testuser".to_string();

    // Generate token with short expiration
    let token = jwt_auth
        .generate_token_with_expiry(user_id, username, std::time::Duration::from_millis(100))
        .unwrap();

    // Token should be valid initially
    assert!(jwt_auth.validate_token(&token).is_ok());

    // Wait for expiration
    tokio::time::sleep(tokio::time::Duration::from_millis(150)).await;

    // Token should be expired
    assert!(jwt_auth.validate_token(&token).is_err());
}

/// Test JWT token refresh
#[tokio::test]
async fn test_jwt_token_refresh() {
    let jwt_auth = JwtAuth::new(b"test_secret_key_32_bytes_long");
    let user_id = "user123".to_string();
    let username = "testuser".to_string();

    // Generate initial token
    let token = jwt_auth
        .generate_token(user_id.clone(), username.clone())
        .unwrap();

    // Refresh token
    let new_token = jwt_auth.refresh_token(&token).unwrap();
    assert_ne!(token, new_token);

    // New token should be valid
    let claims = jwt_auth.validate_token(&new_token).unwrap();
    assert_eq!(claims.user_id, user_id);
    assert_eq!(claims.username, username);
}

/// Test OAuth2 authentication flow
#[tokio::test]
async fn test_oauth2_authentication_flow() {
    let oauth2_store = InMemoryOAuth2Store::new();
    let oauth2_auth = OAuth2Authentication::new(oauth2_store);

    // Register application
    let app = OAuth2Application {
        client_id: "test_client".to_string(),
        client_secret: "test_secret".to_string(),
        redirect_uri: "http://localhost:8080/callback".to_string(),
        scopes: vec!["read".to_string(), "write".to_string()],
    };

    oauth2_auth.register_application(app).await.unwrap();

    // Generate authorization code
    let auth_code = oauth2_auth
        .generate_authorization_code(
            "test_client",
            "user123",
            "http://localhost:8080/callback",
            &["read", "write"],
        )
        .await
        .unwrap();

    assert!(!auth_code.code.is_empty());

    // Exchange code for token
    let token = oauth2_auth
        .exchange_code_for_token(
            &auth_code.code,
            "test_client",
            "test_secret",
            "http://localhost:8080/callback",
        )
        .await
        .unwrap();

    assert!(!token.access_token.is_empty());
    assert_eq!(token.token_type, "Bearer");
}

/// Test OAuth2 token validation
#[tokio::test]
async fn test_oauth2_token_validation() {
    let oauth2_store = InMemoryOAuth2Store::new();
    let oauth2_auth = OAuth2Authentication::new(oauth2_store);

    // Register application and generate token
    let app = OAuth2Application {
        client_id: "test_client".to_string(),
        client_secret: "test_secret".to_string(),
        redirect_uri: "http://localhost:8080/callback".to_string(),
        scopes: vec!["read".to_string()],
    };

    oauth2_auth.register_application(app).await.unwrap();

    let auth_code = oauth2_auth
        .generate_authorization_code(
            "test_client",
            "user123",
            "http://localhost:8080/callback",
            &["read"],
        )
        .await
        .unwrap();

    let token = oauth2_auth
        .exchange_code_for_token(
            &auth_code.code,
            "test_client",
            "test_secret",
            "http://localhost:8080/callback",
        )
        .await
        .unwrap();

    // Validate token
    let validation_result = oauth2_auth
        .validate_token(&token.access_token)
        .await
        .unwrap();
    assert!(validation_result.is_valid);
    assert_eq!(validation_result.user_id, "user123");
    assert!(validation_result.scopes.contains(&"read".to_string()));
}

/// Test MFA (Multi-Factor Authentication) setup
#[tokio::test]
async fn test_mfa_setup() {
    let mfa_store = InMemoryMfaStore::new();
    let mfa_manager = MfaManager::new(mfa_store);

    let user_id = "user123".to_string();

    // Setup TOTP device
    let device = mfa_manager
        .create_totp_device(&user_id, "Test Device")
        .await
        .unwrap();
    assert!(!device.secret.is_empty());
    assert_eq!(device.user_id, user_id);
    assert_eq!(device.name, "Test Device");

    // Generate backup codes
    let backup_codes = mfa_manager
        .generate_backup_codes(&user_id, 5)
        .await
        .unwrap();
    assert_eq!(backup_codes.len(), 5);

    // Verify TOTP code
    let code = generate_totp_code(&device.secret).unwrap();
    let is_valid = mfa_manager.verify_totp_code(&user_id, &code).await.unwrap();
    assert!(is_valid);
}

/// Test MFA verification with backup codes
#[tokio::test]
async fn test_mfa_backup_codes() {
    let mfa_store = InMemoryMfaStore::new();
    let mfa_manager = MfaManager::new(mfa_store);

    let user_id = "user123".to_string();

    // Generate backup codes
    let backup_codes = mfa_manager
        .generate_backup_codes(&user_id, 3)
        .await
        .unwrap();
    let backup_code = &backup_codes[0];

    // Verify backup code
    let is_valid = mfa_manager
        .verify_backup_code(&user_id, backup_code)
        .await
        .unwrap();
    assert!(is_valid);

    // Verify same backup code is consumed
    let is_valid_again = mfa_manager
        .verify_backup_code(&user_id, backup_code)
        .await
        .unwrap();
    assert!(!is_valid_again);
}

/// Test rate limiting permission
#[tokio::test]
async fn test_rate_limiting_permission() {
    let rate_limit_store = InMemoryRateLimitStore::new();
    let rate_limit_config = RateLimitConfig {
        max_requests: 5,
        window_duration: std::time::Duration::from_secs(60),
    };

    let rate_limit_permission =
        RateLimitPermission::new(rate_limit_config, rate_limit_store, "test_key".to_string());

    let context = PermissionContext {
        request: &create_test_request(),
        is_authenticated: true,
        is_admin: false,
        is_active: true,
    };

    // First 5 requests should be allowed
    for i in 0..5 {
        let has_permission = rate_limit_permission.has_permission(&context).await;
        assert!(has_permission, "Request {} should be allowed", i + 1);
    }

    // 6th request should be denied
    let has_permission = rate_limit_permission.has_permission(&context).await;
    assert!(
        !has_permission,
        "Request 6 should be denied due to rate limit"
    );
}

/// Test IP whitelist permission
#[tokio::test]
async fn test_ip_whitelist_permission() {
    let whitelist = vec!["192.168.1.0/24".to_string(), "10.0.0.0/8".to_string()];
    let ip_whitelist_permission = IpWhitelistPermission::new(whitelist);

    // Test whitelisted IP
    let mut request = create_test_request();
    request
        .headers
        .insert("x-forwarded-for", "192.168.1.100".parse().unwrap());

    let context = PermissionContext {
        request: &request,
        is_authenticated: true,
        is_admin: false,
        is_active: true,
    };

    assert!(ip_whitelist_permission.has_permission(&context).await);

    // Test non-whitelisted IP
    let mut request = create_test_request();
    request
        .headers
        .insert("x-forwarded-for", "203.0.113.1".parse().unwrap());

    let context = PermissionContext {
        request: &request,
        is_authenticated: true,
        is_admin: false,
        is_active: true,
    };

    assert!(!ip_whitelist_permission.has_permission(&context).await);
}

/// Test IP blacklist permission
#[tokio::test]
async fn test_ip_blacklist_permission() {
    let blacklist = vec!["192.168.1.100".to_string(), "10.0.0.50".to_string()];
    let ip_blacklist_permission = IpBlacklistPermission::new(blacklist);

    // Test blacklisted IP
    let mut request = create_test_request();
    request
        .headers
        .insert("x-forwarded-for", "192.168.1.100".parse().unwrap());

    let context = PermissionContext {
        request: &request,
        is_authenticated: true,
        is_admin: false,
        is_active: true,
    };

    assert!(!ip_blacklist_permission.has_permission(&context).await);

    // Test non-blacklisted IP
    let mut request = create_test_request();
    request
        .headers
        .insert("x-forwarded-for", "192.168.1.200".parse().unwrap());

    let context = PermissionContext {
        request: &request,
        is_authenticated: true,
        is_admin: false,
        is_active: true,
    };

    assert!(ip_blacklist_permission.has_permission(&context).await);
}

/// Test time-based permission
#[tokio::test]
async fn test_time_based_permission() {
    let time_window = TimeWindow {
        start_hour: 9,
        start_minute: 0,
        end_hour: 17,
        end_minute: 0,
        days_of_week: vec![1, 2, 3, 4, 5], // Monday to Friday
    };

    let time_permission = TimeBasedPermission::new(time_window);

    let context = PermissionContext {
        request: &create_test_request(),
        is_authenticated: true,
        is_admin: false,
        is_active: true,
    };

    // Test during business hours (simulated)
    let has_permission = time_permission.has_permission(&context).await;
    // Note: This test depends on the current time, so we just verify it doesn't panic
    assert!(has_permission || !has_permission); // Either true or false is valid
}

/// Test composite authentication backend
#[tokio::test]
async fn test_composite_authentication_backend() {
    let jwt_auth = JwtAuth::new(b"test_secret_key_32_bytes_long");
    let basic_auth = BasicAuthentication::new();

    let composite_backend = CompositeAuthBackend::new()
        .add_backend("jwt", Box::new(jwt_auth))
        .add_backend("basic", Box::new(basic_auth));

    // Test JWT authentication
    let mut request = create_test_request();
    request
        .headers
        .insert("authorization", "Bearer test_token".parse().unwrap());

    let result = composite_backend.authenticate(&request).await;
    // Result depends on implementation, but should not panic
    assert!(result.is_ok() || result.is_err());
}

/// Test session authentication
#[tokio::test]
async fn test_session_authentication() {
    let session_store = SessionStore::new();
    let session_auth = SessionAuthentication::new(session_store);

    let user_id = "user123".to_string();

    // Create session
    let session_id = session_auth.create_session(&user_id).await.unwrap();
    assert!(!session_id.is_empty());

    // Authenticate with session
    let mut request = create_test_request();
    request.headers.insert(
        "cookie",
        format!("sessionid={}", session_id).parse().unwrap(),
    );

    let user = session_auth.authenticate(&request).await.unwrap();
    assert!(user.is_some());
    assert_eq!(user.unwrap().id(), user_id);
}

/// Test token blacklist functionality
#[tokio::test]
async fn test_token_blacklist() {
    let blacklist = InMemoryTokenBlacklist::new();
    let token = "test_token_123".to_string();

    // Token should not be blacklisted initially
    assert!(!blacklist.is_blacklisted(&token).await.unwrap());

    // Add token to blacklist
    blacklist
        .blacklist_token(&token, BlacklistReason::UserLogout)
        .await
        .unwrap();

    // Token should be blacklisted now
    assert!(blacklist.is_blacklisted(&token).await.unwrap());

    // Get blacklist stats
    let stats = blacklist.get_stats().await.unwrap();
    assert_eq!(stats.total_blacklisted, 1);
    assert_eq!(stats.logout_count, 1);
}

/// Test token rotation
#[tokio::test]
async fn test_token_rotation() {
    let refresh_store = InMemoryRefreshTokenStore::new();
    let rotation_manager = TokenRotationManager::new(refresh_store);

    let user_id = "user123".to_string();
    let old_token = "old_access_token".to_string();

    // Create refresh token
    let refresh_token = rotation_manager
        .create_refresh_token(&user_id, &old_token)
        .await
        .unwrap();
    assert!(!refresh_token.token.is_empty());

    // Rotate token
    let new_token = rotation_manager
        .rotate_token(&refresh_token.token)
        .await
        .unwrap();
    assert!(!new_token.access_token.is_empty());
    assert_ne!(new_token.access_token, old_token);

    // Old token should be invalidated
    assert!(rotation_manager.is_token_valid(&old_token).await.unwrap());
}

/// Test model permissions
#[tokio::test]
async fn test_model_permissions() {
    let model_permission = DjangoModelPermissions::new();

    let context = PermissionContext {
        request: &create_test_request(),
        is_authenticated: true,
        is_admin: false,
        is_active: true,
    };

    // Test GET request (read permission)
    let mut get_request = create_test_request();
    get_request.method = hyper::Method::GET;

    let get_context = PermissionContext {
        request: &get_request,
        is_authenticated: true,
        is_admin: false,
        is_active: true,
    };

    assert!(model_permission.has_permission(&get_context).await);

    // Test POST request (write permission)
    let mut post_request = create_test_request();
    post_request.method = hyper::Method::POST;

    let post_context = PermissionContext {
        request: &post_request,
        is_authenticated: true,
        is_admin: false,
        is_active: true,
    };

    assert!(model_permission.has_permission(&post_context).await);
}

/// Test permission combinators
#[tokio::test]
async fn test_permission_combinators() {
    let is_authenticated = IsAuthenticated;
    let is_admin = IsAdminUser;

    // Test AND combinator
    let and_permission = AndPermission::new(Box::new(is_authenticated), Box::new(is_admin));

    let admin_context = PermissionContext {
        request: &create_test_request(),
        is_authenticated: true,
        is_admin: true,
        is_active: true,
    };

    assert!(and_permission.has_permission(&admin_context).await);

    let user_context = PermissionContext {
        request: &create_test_request(),
        is_authenticated: true,
        is_admin: false,
        is_active: true,
    };

    assert!(!and_permission.has_permission(&user_context).await);

    // Test OR combinator
    let or_permission = OrPermission::new(Box::new(is_authenticated), Box::new(is_admin));

    assert!(or_permission.has_permission(&admin_context).await);
    assert!(or_permission.has_permission(&user_context).await);

    // Test NOT combinator
    let not_permission = NotPermission::new(Box::new(is_admin));

    assert!(!not_permission.has_permission(&admin_context).await);
    assert!(not_permission.has_permission(&user_context).await);
}

/// Test password hashing
#[test]
fn test_password_hashing() {
    let hasher = Argon2Hasher::new();
    let password = "test_password_123".to_string();

    // Hash password
    let hashed = hasher.hash_password(&password).unwrap();
    assert!(!hashed.is_empty());
    assert_ne!(hashed, password);

    // Verify password
    let is_valid = hasher.verify_password(&password, &hashed).unwrap();
    assert!(is_valid);

    // Verify wrong password
    let is_invalid = hasher.verify_password("wrong_password", &hashed).unwrap();
    assert!(!is_invalid);
}

/// Test user model functionality
#[test]
fn test_user_model() {
    let user = SimpleUser {
        id: uuid::Uuid::new_v4(),
        username: "testuser".to_string(),
        email: "test@example.com".to_string(),
        is_active: true,
        is_admin: false,
    };

    assert!(!user.id().is_empty());
    assert_eq!(user.username(), "testuser");
    assert_eq!(user.email(), "test@example.com");
    assert!(user.is_authenticated());
    assert!(user.is_active());
    assert!(!user.is_admin());
}

/// Test anonymous user
#[test]
fn test_anonymous_user() {
    let user = AnonymousUser;

    assert_eq!(user.id(), "");
    assert_eq!(user.username(), "");
    assert!(!user.is_authenticated());
    assert!(!user.is_active());
    assert!(!user.is_admin());
}

// Helper functions for authentication testing
fn create_test_request() -> reinhardt_types::Request {
    use bytes::Bytes;
    use hyper::{HeaderMap, Method, Uri, Version};

    Request::new(
        Method::GET,
        Uri::from_static("/test"),
        Version::HTTP_11,
        HeaderMap::new(),
        Bytes::new(),
    )
}

fn generate_totp_code(secret: &str) -> Result<String, Box<dyn std::error::Error>> {
    // Simplified TOTP code generation for testing
    use std::time::{SystemTime, UNIX_EPOCH};

    let timestamp = SystemTime::now().duration_since(UNIX_EPOCH)?.as_secs();
    let time_step = 30;
    let counter = timestamp / time_step;

    // Simplified HMAC-SHA1 calculation
    let mut hmac = [0u8; 20];
    for (i, byte) in secret.as_bytes().iter().enumerate() {
        hmac[i % 20] ^= byte;
    }

    let code = (hmac[0] as u32 % 1000000).to_string();
    Ok(format!("{:06}", code))
}
