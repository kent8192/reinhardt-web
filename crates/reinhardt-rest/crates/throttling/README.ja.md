# reinhardt-throttling

Reinhardtフレームワーク用のレート制限とスロットリング

## 概要

API不正利用を防止し、公平なリソース配分を保証するための包括的なレート制限システムです。柔軟なバックエンドストレージオプションを持つ複数のスロットリング戦略を提供します。

## 実装済み ✓

### コアスロットルシステム

- **`Throttle` トレイト**: スロットリングインターフェースを定義する非同期トレイト
  - `allow_request`: リクエストを許可すべきかチェック
  - `wait_time`: 再試行前の待機時間を取得
  - `get_rate`: 設定されたレート制限を取得
- **`ThrottleError`**: スロットリング操作のエラーハンドリング
- **`ThrottleResult<T>`**: スロットル操作用の結果型エイリアス

### スロットル実装

#### 匿名ユーザースロットリング

- **`AnonRateThrottle`**: 匿名ユーザー向けレート制限(IPアドレス基準)
  - メモリバックエンドのコンストラクタ: `new(rate, window_secs)`
  - カスタムバックエンドのコンストラクタ: `with_backend(rate, window_secs, backend)`
  - キーに `throttle:anon:` プレフィックスを自動付与
  - 例: 匿名ユーザーに1時間あたり60リクエストを許可

#### 認証済みユーザースロットリング

- **`UserRateThrottle`**: 認証済みユーザー向けレート制限(ユーザーID基準)
  - メモリバックエンドのコンストラクタ: `new(rate, window_secs)`
  - カスタムバックエンドのコンストラクタ: `with_backend(rate, window_secs, backend)`
  - キーに `throttle:user:` プレフィックスを自動付与
  - ウィンドウ有効期限付きのユーザーごとのレート制限
  - 例: ユーザーごとに60秒あたり100リクエストを許可

#### スコープ付きスロットリング

- **`ScopedRateThrottle`**: エンドポイントごとまたはカスタムスコープのレート制限
  - メモリバックエンドのコンストラクタ: `new()`
  - カスタムバックエンドのコンストラクタ: `with_backend(backend)`
  - スコープ追加のビルダーパターン: `add_scope(scope, rate, window)`
  - キーフォーマット: `scope:identifier` (例: `"api:user1"`, `"upload:user2"`)
  - スコープごとに異なるレート制限
  - スコープなしリクエストはスロットリング対象外
  - 例: APIスコープ100/分、アップロードスコープ10/分

#### バーストレートスロットリング

- **`BurstRateThrottle`**: バーストレートと持続レートの二重ウィンドウスロットリング
  - バーストレート(短期ウィンドウ)と持続レート(長期ウィンドウ)を分離
  - コンストラクタ: `new(backend, burst_rate, sustained_rate, burst_duration, sustained_duration)`
  - リクエスト通過には両方のレート制限を満たす必要あり
  - 例: バースト1秒あたり10リクエスト、持続1分あたり100リクエスト

#### 階層型レートスロットリング

- **`TieredRateThrottle`**: ユーザーレベルベースのスロットリング(例: 無料版 vs プレミアム版)
  - 階層設定を定義する `Tier` 構造体
  - コンストラクタ: `new(backend, default_tier)`
  - 階層追加: `add_tier(tier)`
  - 階層取得: `get_tier(tier_name)`
  - キーフォーマット: `tier_name:user_id`
  - 不明な階層名はデフォルト階層にフォールバック
  - 例: 無料階層100/時間、プレミアム階層1000/時間

### バックエンドストレージ

#### メモリバックエンド

- **`MemoryBackend`**: インメモリレート制限追跡
  - デフォルトコンストラクタ: `new()`
  - タイムプロバイダー付き: `with_time_provider(time_provider)`
  - ウィンドウ自動有効期限付きHashMapベースストレージ
  - `Arc<RwLock<HashMap>>` によるスレッドセーフ
  - `Default` トレイト実装
  - 単一サーバーデプロイメントに最適

#### Redisバックエンド

- **`RedisBackend`**: 分散レート制限(機能フラグ: `redis-backend`)
  - コンストラクタ: `new(url)` - Redis接続URL指定
  - Redis INCRとEXPIREコマンドを使用
  - 複数サーバー間での分散レート制限をサポート
  - 非同期コネクションプーリングと多重化接続

#### バックエンドトレイト

- **`ThrottleBackend`**: 全バックエンド共通インターフェース
  - `increment(key, window)`: 有効期限付きカウンタインクリメント
  - `get_count(key)`: 現在のリクエスト数を取得
  - `increment_duration(key, window)`: 期間ベースのインクリメント
  - `get_wait_time(key)`: レート制限リセットまでの時間を取得

### テストユーティリティ

- **`TimeProvider` トレイト**: テスト可能性のための時間抽象化
  - `now()`: 現在時刻を取得
- **`SystemTimeProvider`**: 実際のシステム時刻実装
  - `tokio::time::Instant::now()` を使用
- **`MockTimeProvider`**: テスト用の制御可能な時間
  - `new(start_time)`: 初期時刻を指定して作成
  - `advance(duration)`: 時間を前進
  - `set_time(time)`: 絶対時刻を設定
  - `Arc<RwLock<Instant>>` によるスレッドセーフ

## 予定

### 高度な機能

- レート制限同期のための分散コンセンサス
- バックエンド障害時のグレースフルデグラデーション
- レート制限のウォームアップとクールダウン戦略
- システム負荷に基づく適応型レート制限
- レート制限分析とレポート機能
- トークンバケットアルゴリズム実装
- リーキーバケットアルゴリズム実装

### バックエンド拡張

- Memcachedバックエンドサポート
- データベースバックのレート制限
- フォールバック付き多層キャッシング
- カスタムバックエンドプラグインシステム

### 追加スロットルタイプ

- 同時リクエストスロットリング
- 帯域幅スロットリング
- 地域ベースのレート制限
- 時間帯ベースのレート制限
- 動的レート調整

## 機能フラグ

- `redis-backend`: Redisバックエンドサポートを有効化(Redisクライアント依存関係が必要)

## 使用例

詳細な使用例については、各モジュールのドキュメントテストを参照してください:

- メモリバックエンドスロットリング
- Redis分散スロットリング
- MockTimeProviderによる時間ベーステスト
- 複数のスロットル戦略
