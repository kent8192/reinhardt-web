//! Views for api app
//!
//! RESTful API endpoints

use reinhardt::{Request, Response, StatusCode, ViewResult, endpoint};
use reinhardt::db::orm::Manager;
use crate::apps::api::models::Article;
use chrono::Utc;
use std::sync::Arc;
use validator::Validate;

use super::serializers::{ArticleListResponse, ArticleResponse, CreateArticleRequest};

/// List all articles
///
/// # Example Response
/// ```json
/// {
///   "count": 2,
///   "results": [
///     {
///       "id": 1,
///       "title": "Introduction to Reinhardt",
///       "content": "Reinhardt is a batteries-included web framework...",
///       "author": "John Doe",
///       "published": true,
///       "created_at": "2025-01-01T00:00:00Z",
///       "updated_at": "2025-01-01T00:00:00Z"
///     }
///   ]
/// }
/// ```
#[endpoint]
pub async fn list_articles(
	_req: Request,
	#[inject] db: Arc<reinhardt::db::DatabaseConnection>,
) -> ViewResult<Response> {
	// Query all articles from database using ORM
	let manager = Manager::<Article>::new();
	let articles = manager.all().all().await?;

	let results: Vec<ArticleResponse> = articles.into_iter().map(Into::into).collect();

	let response = ArticleListResponse {
		count: results.len(),
		results,
	};

	Ok(Response::new(
		StatusCode::OK,
		serde_json::to_vec(&response)?,
	))
}

/// Create a new article
///
/// # Request Body
/// ```json
/// {
///   "title": "Introduction to Reinhardt",
///   "content": "Reinhardt is a batteries-included web framework for Rust...",
///   "author": "John Doe",
///   "published": true
/// }
/// ```
#[endpoint]
pub async fn create_article(
	mut req: Request,
	#[inject] db: Arc<reinhardt::db::DatabaseConnection>,
) -> ViewResult<Response> {
	// Parse request body
	let body_bytes = std::mem::take(&mut req.body);
	let create_req: CreateArticleRequest = serde_json::from_slice(&body_bytes)?;

	// Validate request
	create_req.validate()?;

	// Create new article using ORM
	let now = Utc::now();
	let article = Article {
		id: 0, // Will be auto-generated by database
		title: create_req.title,
		content: create_req.content,
		author: create_req.author,
		published: create_req.published,
		created_at: now,
		updated_at: now,
	};

	let manager = Manager::<Article>::new();
	let created_article = manager.create(article).await?;

	let response: ArticleResponse = created_article.into();

	Ok(Response::new(
		StatusCode::CREATED,
		serde_json::to_vec(&response)?,
	))
}

/// Get a specific article by ID
///
/// # Path Parameters
/// - `id`: Article ID (e.g., `/articles/1`)
#[endpoint]
pub async fn get_article(
	req: Request,
	#[inject] db: Arc<reinhardt::db::DatabaseConnection>,
) -> ViewResult<Response> {
	// Extract ID from path parameters
	let id = req
		.path_params
		.get("id")
		.ok_or("Missing path parameter: id")?
		.parse::<i64>()
		.map_err(|_| "Invalid ID format")?;

	// Get article from database using ORM
	let manager = Manager::<Article>::new();
	let article = manager
		.get(id)
		.await
		.map_err(|_| format!("Article with id {} not found", id))?;

	let response: ArticleResponse = article.into();

	Ok(Response::new(
		StatusCode::OK,
		serde_json::to_vec(&response)?,
	))
}

/// Update an article
///
/// # Path Parameters
/// - `id`: Article ID (e.g., `/articles/1`)
///
/// # Request Body
/// Partial update supported - all fields are optional:
/// ```json
/// {
///   "title": "Updated Title",
///   "content": "Updated content...",
///   "published": false
/// }
/// ```
#[endpoint]
pub async fn update_article(
	mut req: Request,
	#[inject] db: Arc<reinhardt::db::DatabaseConnection>,
) -> ViewResult<Response> {
	// Extract ID from path parameters
	let id = req
		.path_params
		.get("id")
		.ok_or("Missing path parameter: id")?
		.parse::<i64>()
		.map_err(|_| "Invalid ID format")?;

	// Parse request body
	let body_bytes = std::mem::take(&mut req.body);
	let update_data: serde_json::Value = serde_json::from_slice(&body_bytes)?;

	// Get existing article from database
	let manager = Manager::<Article>::new();
	let mut article = manager
		.get(id)
		.await
		.map_err(|_| format!("Article with id {} not found", id))?;

	// Apply partial updates
	if let Some(title) = update_data.get("title").and_then(|v| v.as_str()) {
		article.title = title.to_string();
	}
	if let Some(content) = update_data.get("content").and_then(|v| v.as_str()) {
		article.content = content.to_string();
	}
	if let Some(author) = update_data.get("author").and_then(|v| v.as_str()) {
		article.author = author.to_string();
	}
	if let Some(published) = update_data.get("published").and_then(|v| v.as_bool()) {
		article.published = published;
	}
	article.updated_at = Utc::now();

	// Save updated article
	let updated_article = manager.update(article).await?;

	let response: ArticleResponse = updated_article.into();

	Ok(Response::new(
		StatusCode::OK,
		serde_json::to_vec(&response)?,
	))
}

/// Delete an article
///
/// # Path Parameters
/// - `id`: Article ID (e.g., `/articles/1`)
///
/// # Response
/// Returns 204 No Content on success
#[endpoint]
pub async fn delete_article(
	req: Request,
	#[inject] db: Arc<reinhardt::db::DatabaseConnection>,
) -> ViewResult<Response> {
	// Extract ID from path parameters
	let id = req
		.path_params
		.get("id")
		.ok_or("Missing path parameter: id")?
		.parse::<i64>()
		.map_err(|_| "Invalid ID format")?;

	// Delete article from database using ORM
	let manager = Manager::<Article>::new();
	manager
		.delete(id)
		.await
		.map_err(|_| format!("Article with id {} not found", id))?;

	Ok(Response::new(StatusCode::NO_CONTENT, Vec::new()))
}
